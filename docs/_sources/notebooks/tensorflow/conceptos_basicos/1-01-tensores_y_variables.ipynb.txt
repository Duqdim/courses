{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": false
   },
   "source": [
    "Tensores y Variables en TensorFlow 2.4\n",
    "==="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* 30:00 min | Última modificación: Mayo 10, 2021 | [YouTube]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Adaptado de:\n",
    "\n",
    "* https://www.tensorflow.org/tutorials/keras/keras_tuner"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Esta lección presenta una introducción al cómputo numérico usando la API de bajo nivel de TensorFlow, a partir de la cual se construiran modelos de aprendizaje automático en lecciones posteriores. El lector puede referirse a los sitios de oficiales de Keras (https://keras.io) y TensorFlow (https://www.tensorflow.org) para mayor información y para obtener una visión más profunda de las herramientas y metodologías disponibles."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Representación de cómputos mediante su árbol sintáctico."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En el siguiente ejemplo se evaluará la expresión 5 * 3 - (3 + 2). Esta expresión puede ser representada a través del siguiente árbol sintáctico donde los nodos interiores representan las operaciones aritméticas y los nodos finales representan las constantes numéricas:\n",
    "\n",
    "     [-]\n",
    "      +--- [*]\n",
    "      |     +---- [5]\n",
    "      |     +---- [3]\n",
    "      |\n",
    "      +--- [+]\n",
    "            +---- [3]\n",
    "            +---- [2]\n",
    "\n",
    "Note que en esta expresión el nodo con la constante 3 es común a ambas ramas y podría representarse de forma optimizada como:\n",
    "\n",
    "     [-]\n",
    "      +--- [*]\n",
    "      |     +---- [5]\n",
    "      |     +-----------+\n",
    "      |                 |\n",
    "      +--- [+]         [3] \n",
    "            |           |\n",
    "            +-----------+ \n",
    "            +---- [2]   \n",
    "\n",
    "Si se tiene en cuenta que la constante 3 podría ser reemplazada por un cómputo complejo, se hace evidente que dicho cálculo sería realizado una sola vez con la consiguiente economía en el cómputo. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Gráficas computacionales en TensorFlow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El árbol sintáctico anterior es equivalente a una gráfica que representa los cómputos a realizar (gráfica computacional). Para realizar la representación usando TensorFlow, se debe construir explícitamente el grafo que representa el árbol anterior, para lo cual se enumeran los nodos de la siguiente forma:\n",
    "\n",
    "     [-] (node6)\n",
    "      +--- [*] (node4)\n",
    "      |     +---- [5] (node1)\n",
    "      |     +---------------------+\n",
    "      |                           |\n",
    "      +--- [+] (node5)           [3] (node3)\n",
    "            |                     |\n",
    "            +---------------------+ \n",
    "            +---- [2] (node2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La gráfica computacional está conformado por:\n",
    "\n",
    "* **Tensores**: Representa un vector de cualquier número de dimensiones. El rango (**rank**) es el número de dimensiones y la forma (**shape**) es una tupla de enteros indicando el tamaño en cada dimensión. Note que un escalar es un tensor de forma []. Corresponde a los nodos finales de la gráfica computacional.\n",
    "\n",
    "* **Operaciones**: Representan los cálculos. Son los nodos internos de la gráfica computacional."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El código en Python que representa la gráfica computacional es el siguiente:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('2.4.1', '1.19.5')"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Se importan las librerías\n",
    "#\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "\n",
    "tf.__version__, np.__version__"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "node1 = tf.constant(5.0)           # Tensor []\n",
    "node2 = tf.constant(2.0)           # Tensor []\n",
    "node3 = tf.constant(3.0)           # Tensor []\n",
    "node4 = tf.multiply(node1, node2)  # Operación\n",
    "node5 = tf.add(node3, node2)       # Operación\n",
    "node6 = tf.subtract(node4, node5)  # Operación"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El código anterior representa el flujo de datos del cómputo, pero no realiza propiamente el cálculo. Por ejemplo, la variable `node1` contiene el objeto en memoria (Tensor):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<tf.Tensor: shape=(), dtype=float32, numpy=5.0>"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "node1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Evaluación usando numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<tf.Tensor: shape=(), dtype=float32, numpy=5.0>, 5.0)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "node6, node6.numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<tf.Tensor: shape=(), dtype=float32, numpy=10.0>, 10.0)"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "node4, node4.numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Construya a mano el gráfico de flujo de datos de la expresión\n",
    "\n",
    "$$-0.9 * 2^3 + 2.5 * 2^2 - 3.8 * 2 -4.3$$\n",
    "\n",
    "**Actividad.---** Realice el cómputo anterior usando TensorFlow."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "donde la parte superior corresponde a la grafica colapsada y la parte inferior a la gráfica expandida."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Operaciones con escalares"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En la sección anterior se presentaron algunas operaciones aritméticas con TensorFlow. A continuación se resumen las operaciones aritméticas más comunes (la lista completa de operadores puede ser consultada en https://www.tensorflow.org/api_guides/python/math_ops)\n",
    "\n",
    "    Operacion               equivalente\n",
    "    --------------------------------------\n",
    "    tf.add(a, b)            a + b\n",
    "    tf.multiply(a, b)       a * b\n",
    "    tf.subtract(a, b)       a - b\n",
    "    tf.divide(a, b)         a / b\n",
    "    tf.pow(a, b)            a ** b\n",
    "    tf.mod(a, b)            a % b\n",
    "    \n",
    "    tf.abs(a)               abs(a)\n",
    "    tf.square(a)            a ** 2\n",
    "    tf.sqrt(a)              sqrt(a)\n",
    "    tf.exp(a)               exp(a)\n",
    "    tf.negative(a)          -a\n",
    "    tf.sigmoid(a)           1 / (1 + exp(-a))\n",
    "    tf.sign                 sign(a)\n",
    "    tf.maximum\n",
    "    tf.minimum\n",
    "    \n",
    "    tf.logical_and(a, b)    a & b\n",
    "    tf.logical_or(a, b)     a | b   \n",
    "    tf.greater(a, b)        a > b\n",
    "    tf.greater_equal(a, b)  a >= b\n",
    "    tf.less_equal(a, b)     a <= b\n",
    "    tf.less(a, b)           a < b\n",
    "    tf.logical_not(a)       ~a \n",
    "    tf.equal(a, b)          a == b\n",
    "    tf.not_equal            a != b\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "**Actividad.--** Compute las siguientes expresiones usando TensorFlow y use TensorBoard para visualizar las gráficas computacionales.\n",
    "\n",
    "* $|3 - 4| - (4 - 3)$\n",
    "\n",
    "\n",
    "* $\\sqrt{3^2 - 4*3*1}$\n",
    "\n",
    "\n",
    "* $\\frac{1}{2}*3^2 - \\frac{5*2 - \\exp{(-2)}}{3^2}$\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Operaciones matriciales"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow también soporta una gran cantidad de operaciones matriciales. A continuación se presentan ejemplos de las más comunes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0., 0.],\n",
       "       [0., 0.]], dtype=float32)"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación un tensor de 2x2 con 0s\n",
    "#\n",
    "tf.zeros(shape=(2, 2)).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1., 1.],\n",
       "       [1., 1.]], dtype=float32)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación de un tensor de 2x2 con 1s\n",
    "#\n",
    "tf.ones(shape=(2, 2)).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1., 0., 0., 0.],\n",
       "       [0., 2., 0., 0.],\n",
       "       [0., 0., 3., 0.],\n",
       "       [0., 0., 0., 4.]], dtype=float32)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación de una matriz diagonal\n",
    "#\n",
    "tf.linalg.diag(\n",
    "    [\n",
    "        1.0,\n",
    "        2.0,\n",
    "        3.0,\n",
    "        4.0,\n",
    "    ]\n",
    ").numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-0.2651804 ,  0.42558706],\n",
       "       [ 0.37520844,  1.5612575 ],\n",
       "       [ 0.2579123 ,  0.9017231 ]], dtype=float32)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación de un tensor de 3x2 con números\n",
    "# aleatorios normales estándar\n",
    "#\n",
    "tf.random.normal(\n",
    "    shape=(3, 2),\n",
    "    mean=0,\n",
    "    stddev=1,\n",
    "    seed=None,\n",
    ").numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 0.09287316,  0.94429123],\n",
       "       [-0.84406686,  0.32124898],\n",
       "       [ 0.0421923 , -1.889966  ]], dtype=float32)"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación de un tensor de 3x2 con aleatorios\n",
    "# normales truncados\n",
    "#\n",
    "tf.random.truncated_normal(\n",
    "    shape=(3, 2),\n",
    "    mean=0,\n",
    "    stddev=1,\n",
    "    seed=None,\n",
    ").numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[0.9720522 , 0.10158372],\n",
       "       [0.6503949 , 0.14192045],\n",
       "       [0.26171792, 0.97592807]], dtype=float32)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#\n",
    "# Creación de un tensor de números\n",
    "# aleatorios uniformes de 3x2\n",
    "#\n",
    "tf.random.uniform(\n",
    "    shape=(3, 2),\n",
    "    minval=0,\n",
    "    maxval=1,\n",
    ").numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de un tensor de 3x2 lleno de 4s.\n",
    "#\n",
    "tf.fill(dims=(3, 2), value=4,).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de un tensor de números reales\n",
    "#  igualmente espaciados entre 0.0 y 1.0\n",
    "#\n",
    "tf.linspace(start=0.0, stop=1.0, num=11).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tf.range(start=0.0, limit=1.0, delta=0.1).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de un tensor constante a partir de\n",
    "# una lista de listas que representa una matriz\n",
    "#\n",
    "tf.constant(value=[[1, 2, 3], [4, 5, 6]]).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de un tensor mezclando los elementos\n",
    "# de un tensor constante\n",
    "#\n",
    "tf.random.shuffle(value=tf.constant([1, 2, 3, 4, 5, 6])).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de una matriz de numpy\n",
    "#\n",
    "a = np.ones((3, 3))\n",
    "\n",
    "#\n",
    "# Conversión de numpy a tensor\n",
    "#\n",
    "tf.convert_to_tensor(value=a).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de una matriz de numpy\n",
    "#\n",
    "a = np.ones((3, 3))\n",
    "\n",
    "#\n",
    "# Multiplicación por una constante en TF\n",
    "#\n",
    "tf.multiply(x=a, y=42).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de una matriz de numpy\n",
    "#\n",
    "a = np.ones((3, 3))\n",
    "\n",
    "#\n",
    "# Suma de las columnas de un tensor\n",
    "#\n",
    "print(tf.reduce_sum(input_tensor=a, axis=0).numpy())\n",
    "\n",
    "print(tf.reduce_sum(input_tensor=a, axis=1).numpy())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Creación de una matriz de numpy\n",
    "#\n",
    "a = np.ones((3, 4))\n",
    "\n",
    "#\n",
    "# suma de todos los elementos de un tensor\n",
    "#\n",
    "tf.reduce_sum(input_tensor=a).numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow implementa las siguiente funciones para reducir un tensor (https://www.tensorflow.org/api_guides/python/math_ops#Reduction)\n",
    "\n",
    "    tf.reduce_sum\n",
    "    tf.reduce_prod\n",
    "    tf.reduce_min\n",
    "    tf.reduce_max\n",
    "    tf.reduce_mean\n",
    "    tf.reduce_all\n",
    "    tf.reduce_any\n",
    "    tf.reduce_logsumexp\n",
    "    tf.count_nonzero\n",
    "    tf.accumulate_n\n",
    "    tf.einsum\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = tf.constant([[1, 2, 3], [4, 5, 6]])\n",
    "#\n",
    "# Dimensiones de un tensor\n",
    "#\n",
    "m.get_shape()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Suma de dos tensores\n",
    "#\n",
    "a = m + m\n",
    "a.numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Cambio de las dimensiones de un tensor\n",
    "#\n",
    "print(tf.reshape(tensor=m, shape=(1, 6)).numpy())\n",
    "\n",
    "print(\"---\")\n",
    "\n",
    "print(tf.reshape(tensor=m, shape=(3, 2)).numpy())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# suma varios tensores elemento a elemento\n",
    "#\n",
    "#  |1  2|     |5  0|     |1  2|    |7  4|\n",
    "#  |    |  +  |    |  +  |    |  = |    |\n",
    "#  |3  4|     |0  6|     |3  4|    |6 14|\n",
    "#\n",
    "a = tf.constant([[1, 2], [3, 4]])\n",
    "b = tf.constant([[5, 0], [0, 6]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "(a + b + a).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tf.math.accumulate_n([a, b, a]).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Suma varios tensores elemento a elemento\n",
    "#\n",
    "tf.math.add_n([a, b, a]).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Búsqueda de la posición del valor máximo en un tensor\n",
    "#\n",
    "tf.argmax(tf.constant([1, 3, 2, 4, 0])).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Búsqueda de la posición del valor mínimo en un tensor\n",
    "#\n",
    "tf.argmin(tf.constant([1, 3, 2, 4, 0])).numpy()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "# Aplicación de una función a cada elemento de un tensor\n",
    "# La función f() se aplica al argumento m.\n",
    "#\n",
    "f = lambda m: tf.cond(\n",
    "    tf.greater_equal(m, 0.0),\n",
    "    true_fn=lambda: tf.constant(1.0),\n",
    "    false_fn=lambda: tf.constant(0.0),\n",
    ")\n",
    "#\n",
    "# Define el tensor x\n",
    "#\n",
    "x = tf.constant([10.0, -1.0])\n",
    "\n",
    "#\n",
    "# aplica la función f a cada elemento de x\n",
    "#\n",
    "y = tf.map_fn(f, x)\n",
    "\n",
    "#\n",
    "# Realiza el cómputo\n",
    "#\n",
    "y.numpy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Para las matrices\n",
    "\n",
    "$$\\mathbf{X} =\n",
    "\\left[\n",
    "  \\begin{array}{cc}\n",
    "     1.0 & 2.1 \\\\\n",
    "     1.9 & 3.2 \\\\\n",
    "     3.0 & 3.9 \\\\\n",
    "     4.2 & 5.2 \n",
    "  \\end{array}\n",
    "\\right],\n",
    "\\qquad \\mathbf{y} = \n",
    "\\left[\n",
    "  \\begin{array}{c}\n",
    "     3.1 \\\\\n",
    "     4.0 \\\\\n",
    "     5.1 \\\\\n",
    "     6.1  \n",
    "  \\end{array}\n",
    "\\right]\n",
    "$$\n",
    "\n",
    "compute\n",
    "\n",
    "* $\\mathbf{z} = (\\mathbf{X}' \\mathbf{X})^{-1} \\mathbf{X}' \\mathbf{y}$\n",
    "\n",
    "\n",
    "* $\\mathbf{p} = \\mathbf{X} \\mathbf{z}$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Indique para que sirven las siguientes funciones del modulo `tf` y realice un ejemplo:\n",
    "\n",
    "    tf.clip_by_value\n",
    "    tf.clip_by_norm\n",
    "    tf.clip_by_average_norm\n",
    "    tf.clip_by_global_norm\n",
    "    tf.clip_by_norm\n",
    "    tf.concat\n",
    "    tf.case\n",
    "    tf.cond\n",
    "    tf.cumprod\n",
    "    tf.cumsum\n",
    "    tf.diag\n",
    "    tf.inverse_permutation\n",
    "    tf.log_sigmoid \n",
    "    tf.map_fn\n",
    "    \n",
    "    tf.matrix_inverse\n",
    "    tf.matrix_diag\n",
    "    tf.matrix_set_diag\n",
    "    tf.matrix_solve\n",
    "    tf.matrix_transpose\n",
    "    tf.parallel_stack\n",
    "    tf.stack\n",
    "    tf.random_shuffle\n",
    "    tf.reverse\n",
    "    \n",
    "    tf.maximum\n",
    "    tf.minimum"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## tf.function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En TF 2.0, desaparece el uso de placeholders y variables en favor de @tf.function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "#  Definición de la función\n",
    "#\n",
    "@tf.function\n",
    "def f(a, b, c):\n",
    "    return a * b - (b + c)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "#  Evaluación con constantes\n",
    "#\n",
    "print(f(a=5, b=3, c=2))\n",
    "print(f(a=4, b=2, c=3))\n",
    "print(f(a=4, b=3, c=1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#\n",
    "#  Evaluación con matrices\n",
    "#\n",
    "a = tf.constant(\n",
    "    [\n",
    "        [\n",
    "            1,\n",
    "            0,\n",
    "            0,\n",
    "        ],\n",
    "        [\n",
    "            0,\n",
    "            1,\n",
    "            0,\n",
    "        ],\n",
    "        [\n",
    "            0,\n",
    "            0,\n",
    "            1,\n",
    "        ],\n",
    "    ],\n",
    "    tf.float64,\n",
    ")\n",
    "\n",
    "b = np.random.normal(size=(3, 3))\n",
    "\n",
    "c = np.random.normal(size=(3, 3))\n",
    "\n",
    "f(a, b, c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El siguiente ejemplo presente un acumulador para el calculo de $n = n + 1$.    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#\n",
    "# Se crea la variable y la inicializa a cero\n",
    "#\n",
    "n = tf.Variable(0)\n",
    "for i in range(5):\n",
    "    w = tf.add(n, tf.constant(1))\n",
    "    n.assign(w)\n",
    "    print(n.numpy())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#\n",
    "# Se crea la variable y la inicializa a cero\n",
    "#\n",
    "n = tf.Variable(0)\n",
    "for i in range(5):\n",
    "    n.assign_add(1)\n",
    "    print(n.numpy())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Evalue la función\n",
    "\n",
    "$$f(x) = 0.3x^3 - 0.6x^2 - 0.1x + 0.5$$\n",
    "\n",
    "para el vector\n",
    "\n",
    "\n",
    "$$\\mathbf{x} = \n",
    "\\left[\n",
    "  \\begin{array}{c}\n",
    "     1.0 \\\\\n",
    "     4.2 \\\\\n",
    "     3.1 \\\\\n",
    "     6.3  \n",
    "  \\end{array}\n",
    "\\right]\n",
    "$$\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Genere los 10 primeros términos de la serie de Fibonacci usando TensorFlow.\n",
    "\n",
    "    1, 1, 2, 3, 5, 8, 13, ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Uso de TensorFlow con otras librerías de Python"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Los resultados de cómputos realizados con TensorFlow pueden ser asignados a variables en Python para ser usados directamente con otras librerías. En el siguiente ejemplo, se generan 20 puntos  aleatorios normales estándar y luego se grafican usando `matplotlib`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "%matplotlib inline\n",
    "\n",
    "#\n",
    "# Generación de un tensor de 2x20 con valores aleatorios\n",
    "#\n",
    "a = tf.random.normal([2, 20])\n",
    "\n",
    "#\n",
    "# Cómputo\n",
    "#\n",
    "result = a.numpy()\n",
    "\n",
    "#\n",
    "# Se signan las columnas de la matriz a x y y\n",
    "#\n",
    "x, y = result\n",
    "\n",
    "#\n",
    "# Construye el gráfico\n",
    "#\n",
    "plt.scatter(x, y, color=\"red\");"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
