

<!DOCTYPE html>
<html class="writer-html5" lang="es" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>}; &mdash; documentación de --- Cursos --- - </title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../../../_static/copybutton.js"></script>
        <script type="text/javascript" src="../../../_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Índice" href="../../../genindex.html" />
    <link rel="search" title="Búsqueda" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> --- Cursos ---
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Configuración</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../setup.html">Instalación de Vagrant y Docker</a></li>
</ul>
<p class="caption"><span class="caption-text">Cursos</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../analitica-de-grandes-datos/index.html">Analítica de grandes datos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analitica-financiera/index.html">Analítica Financiera</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analitica-predictiva/index.html">Analítica Predictiva</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ciencia-de-los-datos/index.html">Ciencia de los Datos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fundamentos-de-analitica/index.html">Fundamentos de Analítica</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../productos-de-datos/index.html">Productos de Datos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../redes-neuronales-con-tensorflow/index.html">Redes Neuronales Artificiales</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">--- Cursos ---</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>};</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../_sources/notebooks/tensorflow/guide/create_op.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<p># Create an op</p>
<p>Note: To guarantee that your C++ custom ops are ABI compatible with TensorFlow’s
official pip packages, please follow the guide at
[Custom op repository](<a class="reference external" href="https://github.com/tensorflow/custom-op">https://github.com/tensorflow/custom-op</a>). It has an
end-to-end code example, as well as Docker images for building and distributing
your custom ops.</p>
<p>If you’d like to create an op that isn’t covered by the existing TensorFlow
library, we recommend that you first try writing the op in Python as
a composition of existing Python ops or functions. If that isn’t possible, you
can create a custom C++ op. There are several reasons why you might want to
create a custom C++ op:</p>
<ul class="simple">
<li><p>It’s not easy or possible to express your operation as a composition of
existing ops.</p></li>
<li><p>It’s not efficient to express your operation as a composition of existing
primitives.</p></li>
<li><p>You want to hand-fuse a composition of primitives that a future compiler
would find difficult fusing.</p></li>
</ul>
<p>For example, imagine you want to implement something like «median pooling»,
similar to the «MaxPool» operator, but computing medians over sliding windows
instead of maximum values.  Doing this using a composition of operations may be
possible (e.g., using ExtractImagePatches and TopK), but may not be as
performance- or memory-efficient as a native operation where you can do
something more clever in a single, fused operation. As always, it is typically
first worth trying to express what you want using operator composition, only
choosing to add a new operation if that proves to be difficult or inefficient.</p>
<p>To incorporate your custom op you’ll need to:</p>
<ol class="arabic simple">
<li><p>Register the new op in a C++ file. Op registration defines an interface
(specification) for the op’s functionality, which is independent of the
op’s implementation. For example, op registration defines the op’s name and
the op’s inputs and outputs. It also defines the shape function
that is used for tensor shape inference.</p></li>
<li><p>Implement the op in C++. The implementation of an op is known
as a kernel, and it is the concrete implementation of the specification you
registered in Step 1. There can be multiple kernels for different input /
output types or architectures (for example, CPUs, GPUs).</p></li>
<li><p>Create a Python wrapper (optional). This wrapper is the public API that’s
used to create the op in Python. A default wrapper is generated from the
op registration, which can be used directly or added to.</p></li>
<li><p>Write a function to compute gradients for the op (optional).</p></li>
<li><p>Test the op. We usually do this in Python for convenience, but you can also
test the op in C++. If you define gradients, you can verify them with the
Python <cite>tf.test.compute_gradient_error</cite>.
See
[<cite>relu_op_test.py</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/python/kernel_tests/relu_op_test.py">https://www.tensorflow.org/code/tensorflow/python/kernel_tests/relu_op_test.py</a>) as
an example that tests the forward functions of Relu-like operators and
their gradients.</p></li>
</ol>
<p>### Prerequisites</p>
<ul class="simple">
<li><p>Some familiarity with C++.</p></li>
<li><p>Must have installed the
[TensorFlow binary](../../install), or must have
[downloaded TensorFlow source](../../install/source.md),
and be able to build it.</p></li>
</ul>
<p>## Define the op interface</p>
<p>You define the interface of an op by registering it with the TensorFlow system.
In the registration, you specify the name of your op, its inputs (types and
names) and outputs (types and names), as well as docstrings and
any [attrs](#attrs) the op might require.</p>
<p>To see how this works, suppose you’d like to create an op that takes a tensor of
<cite>int32`s and outputs a copy of the tensor, with all but the first element set to
zero. To do this, create a file named `zero_out.cc</cite>. Then add a call to the
<cite>REGISTER_OP</cite> macro that defines the interface for your op:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>c++
#include «tensorflow/core/framework/op.h»
#include «tensorflow/core/framework/shape_inference.h»</p>
<p>using namespace tensorflow;</p>
<dl>
<dt>REGISTER_OP(«ZeroOut»)</dt><dd><p>.Input(«to_zero: int32»)
.Output(«zeroed: int32»)
.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</p>
<blockquote>
<div><p>c-&gt;set_output(0, c-&gt;input(0));
return Status::OK();</p>
</div></blockquote>
<p>});</p>
</dd>
</dl>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>This <cite>ZeroOut</cite> op takes one tensor <cite>to_zero</cite> of 32-bit integers as input, and
outputs a tensor <cite>zeroed</cite> of 32-bit integers. The op also uses a shape function
to ensure that the output tensor is the same shape as the input tensor. For
example, if the input is a tensor of shape [10, 20], then this shape function
specifies that the output shape is also [10, 20].</p>
<p>Note: The op name must be in CamelCase and it must be unique among all other ops
that are registered in the binary.</p>
<p>## Implement the kernel for the op</p>
<p>After you define the interface, provide one or more implementations of the op.
To create one of these kernels, create a class that extends <cite>OpKernel</cite> and
overrides the <cite>Compute</cite> method. The <cite>Compute</cite> method provides one <cite>context</cite>
argument of type <cite>OpKernelContext*</cite>, from which you can access useful things
like the input and output tensors.</p>
<p>Add your kernel to the file you created above. The kernel might look something
like this:</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>c++
#include «tensorflow/core/framework/op_kernel.h»</p>
<p>using namespace tensorflow;</p>
<dl>
<dt>class ZeroOutOp<span class="classifier">public OpKernel {</span></dt><dd><dl>
<dt>public:</dt><dd><p>explicit ZeroOutOp(OpKernelConstruction* context) : OpKernel(context) {}</p>
<dl>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// Grab the input tensor
const Tensor&amp; input_tensor = context-&gt;input(0);
auto input = input_tensor.flat&lt;int32&gt;();</p>
<p>// Create an output tensor
Tensor* output_tensor = NULL;
OP_REQUIRES_OK(context, context-&gt;allocate_output(0, input_tensor.shape(),</p>
<blockquote>
<div><p>&amp;output_tensor));</p>
</div></blockquote>
<p>auto output_flat = output_tensor-&gt;flat&lt;int32&gt;();</p>
<p>// Set all but the first element of the output tensor to 0.
const int N = input.size();
for (int i = 1; i &lt; N; i++) {</p>
<blockquote>
<div><p>output_flat(i) = 0;</p>
</div></blockquote>
<p>}</p>
<p>// Preserve the first input value if possible.
if (N &gt; 0) output_flat(0) = input(0);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<div class="section" id="id13">
<h1>};<a class="headerlink" href="#id13" title="Enlazar permanentemente con este título">¶</a></h1>
<p>After implementing your kernel, you register it with the TensorFlow system. In
the registration, you specify different constraints under which this kernel
will run. For example, you might have one kernel made for CPUs, and a separate
one for GPUs.</p>
<p>To do this for the <cite>ZeroOut</cite> op, add the following to <cite>zero_out.cc</cite>:</p>
<p><code class="docutils literal notranslate"><span class="pre">`c++</span>
<span class="pre">REGISTER_KERNEL_BUILDER(Name(&quot;ZeroOut&quot;).Device(DEVICE_CPU),</span> <span class="pre">ZeroOutOp);</span>
<span class="pre">`</span></code></p>
<p>&gt;   Important: Instances of your OpKernel may be accessed concurrently.
&gt;   Your <cite>Compute</cite> method must be thread-safe. Guard any access to class
&gt;   members with a mutex. Or better yet, don’t share state via class members!
&gt;   Consider using a [<cite>ResourceMgr</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/resource_mgr.h">https://www.tensorflow.org/code/tensorflow/core/framework/resource_mgr.h</a>)
&gt;   to keep track of op state.</p>
<p>### Multi-threaded CPU kernels</p>
<p>To write a multi-threaded CPU kernel, the Shard function in
[<cite>work_sharder.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/util/work_sharder.h">https://www.tensorflow.org/code/tensorflow/core/util/work_sharder.h</a>)
can be used. This function shards a computation function across the
threads configured to be used for intra-op threading (see
intra_op_parallelism_threads in
[<cite>config.proto</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto">https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto</a>)).</p>
<p>### GPU kernels</p>
<p>A GPU kernel is implemented in two parts: the OpKernel and the CUDA kernel and
its launch code.</p>
<p>Sometimes the OpKernel implementation is common between a CPU and GPU kernel,
such as around inspecting inputs and allocating outputs.  In that case, a
suggested implementation is to:</p>
<ol class="arabic simple">
<li><p>Define the OpKernel templated on the Device and the primitive type of the
tensor.</p></li>
<li><dl class="simple">
<dt>To do the actual computation of the output, the Compute function calls a</dt><dd><p>templated functor struct.</p>
</dd>
</dl>
</li>
<li><p>The specialization of that functor for the CPUDevice is defined in the same
file, but the specialization for the GPUDevice is defined in a .cu.cc file,
since it will be compiled with the CUDA compiler.</p></li>
</ol>
<p>Here is an example implementation.</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>c++
// kernel_example.h
#ifndef <a href="#id434"><span class="problematic" id="id435">KERNEL_EXAMPLE_H_</span></a>
#define <a href="#id436"><span class="problematic" id="id437">KERNEL_EXAMPLE_H_</span></a></p>
<p>#include &lt;unsupported/Eigen/CXX11/Tensor&gt;</p>
<p>template &lt;typename Device, typename T&gt;
struct ExampleFunctor {</p>
<blockquote>
<div><p>void operator()(const Device&amp; d, int size, const T* in, T* out);</p>
</div></blockquote>
<p>};</p>
<p>#if GOOGLE_CUDA
// Partially specialize functor for GpuDevice.
template &lt;typename T&gt;
struct ExampleFunctor&lt;Eigen::GpuDevice, T&gt; {</p>
<blockquote>
<div><p>void operator()(const Eigen::GpuDevice&amp; d, int size, const T* in, T* out);</p>
</div></blockquote>
<p>};
#endif</p>
<p>#endif <a href="#id438"><span class="problematic" id="id439">KERNEL_EXAMPLE_H_</span></a>
<a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a></p>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a>c++
// kernel_example.cc
#include «kernel_example.h»</p>
<p>#include «tensorflow/core/framework/op.h»
#include «tensorflow/core/framework/shape_inference.h»
#include «tensorflow/core/framework/op_kernel.h»</p>
<p>using namespace tensorflow;</p>
<p>using CPUDevice = Eigen::ThreadPoolDevice;
using GPUDevice = Eigen::GpuDevice;</p>
<dl>
<dt>REGISTER_OP(«Example»)</dt><dd><p>.Attr(«T: numbertype»)
.Input(«input: T»)
.Output(«input_times_two: T»)
.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</p>
<blockquote>
<div><p>c-&gt;set_output(0, c-&gt;input(0));
return Status::OK();</p>
</div></blockquote>
<p>});</p>
</dd>
</dl>
<p>// CPU specialization of actual computation.
template &lt;typename T&gt;
struct ExampleFunctor&lt;CPUDevice, T&gt; {</p>
<blockquote>
<div><dl>
<dt>void operator()(const CPUDevice&amp; d, int size, const T* in, T* out) {</dt><dd><dl class="simple">
<dt>for (int i = 0; i &lt; size; ++i) {</dt><dd><p>out[i] = 2 * in[i];</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>};</p>
<p>// OpKernel definition.
// template parameter &lt;T&gt; is the datatype of the tensors.
template &lt;typename Device, typename T&gt;
class ExampleOp : public OpKernel {</p>
<blockquote>
<div><dl>
<dt>public:</dt><dd><p>explicit ExampleOp(OpKernelConstruction* context) : OpKernel(context) {}</p>
<dl>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// Grab the input tensor
const Tensor&amp; input_tensor = context-&gt;input(0);</p>
<p>// Create an output tensor
Tensor* output_tensor = NULL;
OP_REQUIRES_OK(context, context-&gt;allocate_output(0, input_tensor.shape(),</p>
<blockquote>
<div><p>&amp;output_tensor));</p>
</div></blockquote>
<p>// Do the computation.
OP_REQUIRES(context, input_tensor.NumElements() &lt;= tensorflow::kint32max,</p>
<blockquote>
<div><p>errors::InvalidArgument(«Too many elements in tensor»));</p>
</div></blockquote>
<dl class="simple">
<dt>ExampleFunctor&lt;Device, T&gt;()(</dt><dd><p>context-&gt;eigen_device&lt;Device&gt;(),
static_cast&lt;int&gt;(input_tensor.NumElements()),
input_tensor.flat&lt;T&gt;().data(),
output_tensor-&gt;flat&lt;T&gt;().data());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>};</p>
<p>// Register the CPU kernels.
#define REGISTER_CPU(T)                                          </p>
<blockquote>
<div><dl class="simple">
<dt>REGISTER_KERNEL_BUILDER(                                       </dt><dd><p>Name(«Example»).Device(DEVICE_CPU).TypeConstraint&lt;T&gt;(«T»), ExampleOp&lt;CPUDevice, T&gt;);</p>
</dd>
</dl>
</div></blockquote>
<p>REGISTER_CPU(float);
REGISTER_CPU(int32);</p>
<p>// Register the GPU kernels.
#ifdef GOOGLE_CUDA
#define REGISTER_GPU(T)                                          </p>
<blockquote>
<div><p>/* Declare explicit instantiations in kernel_example.cu.cc. <a href="#id26"><span class="problematic" id="id27">*</span></a>/ extern template class ExampleFunctor&lt;GPUDevice, T&gt;;            REGISTER_KERNEL_BUILDER(                                       </p>
<blockquote>
<div><p>Name(«Example»).Device(DEVICE_GPU).TypeConstraint&lt;T&gt;(«T»), ExampleOp&lt;GPUDevice, T&gt;);</p>
</div></blockquote>
</div></blockquote>
<p>REGISTER_GPU(float);
REGISTER_GPU(int32);
#endif  // GOOGLE_CUDA
<a href="#id28"><span class="problematic" id="id29">``</span></a><a href="#id30"><span class="problematic" id="id31">`</span></a></p>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a>c++
// kernel_example.cu.cc
#ifdef GOOGLE_CUDA
#define EIGEN_USE_GPU
#include «kernel_example.h»
#include «tensorflow/core/util/gpu_kernel_helper.h»</p>
<p>using namespace tensorflow;</p>
<p>using GPUDevice = Eigen::GpuDevice;</p>
<p>// Define the CUDA kernel.
template &lt;typename T&gt;
__global__ void ExampleCudaKernel(const int size, const T* in, T* out) {</p>
<blockquote>
<div><dl>
<dt>for (int i = blockIdx.x * blockDim.x + threadIdx.x; i &lt; size;</dt><dd><blockquote>
<div><p>i += blockDim.x * gridDim.x) {</p>
</div></blockquote>
<p>out[i] = 2 * __ldg(in + i);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Define the GPU implementation that launches the CUDA kernel.
template &lt;typename T&gt;
void ExampleFunctor&lt;GPUDevice, T&gt;::operator()(</p>
<blockquote>
<div><blockquote>
<div><p>const GPUDevice&amp; d, int size, const T* in, T* out) {</p>
</div></blockquote>
<p>// Launch the cuda kernel.
//
// See core/util/gpu_kernel_helper.h for example of computing
// block count and thread_per_block count.
int block_count = 1024;
int thread_per_block = 20;
ExampleCudaKernel&lt;T&gt;</p>
<blockquote>
<div><p>&lt;&lt;&lt;block_count, thread_per_block, 0, d.stream()&gt;&gt;&gt;(size, in, out);</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>// Explicitly instantiate functors for the types of OpKernels registered.
template struct ExampleFunctor&lt;GPUDevice, float&gt;;
template struct ExampleFunctor&lt;GPUDevice, int32&gt;;</p>
<p>#endif  // GOOGLE_CUDA
<a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a></p>
<p>## Build the op library</p>
<p>### Compile the op using your system compiler (TensorFlow binary installation)</p>
<p>You should be able to compile <cite>zero_out.cc</cite> with a <cite>C++</cite> compiler such as <cite>g++</cite>
or <cite>clang</cite> available on your system. The binary PIP package installs the header
files and the library that you need to compile your op in locations that are
system specific. However, the TensorFlow python library provides the
<cite>get_include</cite> function to get the header directory, and the <cite>get_lib</cite> directory
has a shared object to link against.
Here are the outputs of these functions on an Ubuntu machine.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">$</span> <span class="pre">python</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">import</span> <span class="pre">tensorflow</span> <span class="pre">as</span> <span class="pre">tf</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">tf.sysconfig.get_include()</span>
<span class="pre">'/usr/local/lib/python3.6/site-packages/tensorflow/include'</span>
<span class="pre">&gt;&gt;&gt;</span> <span class="pre">tf.sysconfig.get_lib()</span>
<span class="pre">'/usr/local/lib/python3.6/site-packages/tensorflow'</span>
<span class="pre">`</span></code></p>
<p>Assuming you have <cite>g++</cite> installed, here is the sequence of commands you can use
to compile your op into a dynamic library.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">TF_CFLAGS=(</span> <span class="pre">$(python</span> <span class="pre">-c</span> <span class="pre">'import</span> <span class="pre">tensorflow</span> <span class="pre">as</span> <span class="pre">tf;</span> <span class="pre">print(&quot;</span> <span class="pre">&quot;.join(tf.sysconfig.get_compile_flags()))')</span> <span class="pre">)</span>
<span class="pre">TF_LFLAGS=(</span> <span class="pre">$(python</span> <span class="pre">-c</span> <span class="pre">'import</span> <span class="pre">tensorflow</span> <span class="pre">as</span> <span class="pre">tf;</span> <span class="pre">print(&quot;</span> <span class="pre">&quot;.join(tf.sysconfig.get_link_flags()))')</span> <span class="pre">)</span>
<span class="pre">g++</span> <span class="pre">-std=c++11</span> <span class="pre">-shared</span> <span class="pre">zero_out.cc</span> <span class="pre">-o</span> <span class="pre">zero_out.so</span> <span class="pre">-fPIC</span> <span class="pre">${TF_CFLAGS[&#64;]}</span> <span class="pre">${TF_LFLAGS[&#64;]}</span> <span class="pre">-O2</span>
<span class="pre">`</span></code></p>
<p>On macOS, the additional flag «-undefined dynamic_lookup» is required when
building the <cite>.so</cite> file.</p>
<p>&gt;   Note on <cite>gcc</cite> version <cite>&gt;=5</cite>: gcc uses the new C++
&gt;   [ABI](<a class="reference external" href="https://gcc.gnu.org/gcc-5/changes.html#libstdcxx">https://gcc.gnu.org/gcc-5/changes.html#libstdcxx</a>) since version <cite>5</cite>. The binary pip
&gt;   packages available on the TensorFlow website are built with <cite>gcc4</cite> that uses
&gt;   the older ABI. If you compile your op library with <cite>gcc&gt;=5</cite>, add
&gt;   <cite>-D_GLIBCXX_USE_CXX11_ABI=0</cite> to the command line to make the library
&gt;   compatible with the older abi.</p>
<p>### Compile the op using bazel (TensorFlow source installation)</p>
<p>If you have TensorFlow sources installed, you can make use of TensorFlow’s build
system to compile your op. Place a BUILD file with following Bazel build rule in
the [<cite>tensorflow/core/user_ops</cite>][user_ops] directory.</p>
<p><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a>python
load(«//tensorflow:tensorflow.bzl», «tf_custom_op_library»)</p>
<dl class="simple">
<dt>tf_custom_op_library(</dt><dd><p>name = «zero_out.so»,
srcs = [«zero_out.cc»],</p>
</dd>
</dl>
</div>
<div class="section" id="id44">
<h1>)<a class="headerlink" href="#id44" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Run the following command to build <cite>zero_out.so</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">$</span> <span class="pre">bazel</span> <span class="pre">build</span> <span class="pre">--config</span> <span class="pre">opt</span> <span class="pre">//tensorflow/core/user_ops:zero_out.so</span>
<span class="pre">`</span></code></p>
<p>For compiling the <cite>Example</cite> operation, with the CUDA Kernel, you need to use the <cite>gpu_srcs</cite> parameter
of <cite>tf_custom_op_library</cite>. Place a BUILD file with the following Bazel build rule in a new folder
inside the [<cite>tensorflow/core/user_ops</cite>][user_ops] directory (e.g. «example_gpu»).</p>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a>python
load(«//tensorflow:tensorflow.bzl», «tf_custom_op_library»)</p>
<dl class="simple">
<dt>tf_custom_op_library(</dt><dd><p># kernel_example.cc  kernel_example.cu.cc  kernel_example.h
name = «kernel_example.so»,
srcs = [«kernel_example.h», «kernel_example.cc»],
gpu_srcs = [«kernel_example.cu.cc», «kernel_example.h»],</p>
</dd>
</dl>
</div>
<div class="section" id="id49">
<h1>)<a class="headerlink" href="#id49" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Run the following command to build <cite>kernel_example.so</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">$</span> <span class="pre">bazel</span> <span class="pre">build</span> <span class="pre">--config</span> <span class="pre">opt</span> <span class="pre">//tensorflow/core/user_ops/example_gpu:kernel_example.so</span>
<span class="pre">`</span></code></p>
<p>Note: As explained above, if you are compiling with gcc&gt;=5 add
<cite>–cxxopt=»-D_GLIBCXX_USE_CXX11_ABI=0»</cite> to the Bazel command line arguments.</p>
<p>&gt;   Note: Although you can create a shared library (a <cite>.so</cite> file) with the
&gt;   standard <cite>cc_library</cite> rule, we strongly recommend that you use the
&gt;   <cite>tf_custom_op_library</cite> macro. It adds some required dependencies, and
&gt;   performs checks to ensure that the shared library is compatible with
&gt;   TensorFlow’s plugin loading mechanism.</p>
<p>## Use the op in Python</p>
<p>TensorFlow Python API provides the
<cite>tf.load_op_library</cite> function to
load the dynamic library and register the op with the TensorFlow
framework. <cite>load_op_library</cite> returns a Python module that contains the Python
wrappers for the op and the kernel. Thus, once you have built the op, you can
do the following to run it from Python:</p>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a>python
import tensorflow as tf
zero_out_module = tf.load_op_library(“./zero_out.so”)
print(zero_out_module.zero_out([[1, 2], [3, 4]]).numpy())</p>
<p># Prints
array([[1, 0], [0, 0]], dtype=int32)
<a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a></p>
<p>Keep in mind, the generated function will be given a snake_case name (to comply
with [PEP8](<a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a>)). So, if your op is
named <cite>ZeroOut</cite> in the C++ files, the python function will be called <cite>zero_out</cite>.</p>
<p>To make the op available as a regular function <cite>import</cite>-able from a Python
module, it maybe useful to have the <cite>load_op_library</cite> call in a Python source
file as follows:</p>
<p><a href="#id58"><span class="problematic" id="id59">``</span></a><a href="#id60"><span class="problematic" id="id61">`</span></a>python
import tensorflow as tf</p>
<p>zero_out_module = tf.load_op_library(“./zero_out.so”)
zero_out = zero_out_module.zero_out
<a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a></p>
<p>## Verify that the op works</p>
<p>A good way to verify that you’ve successfully implemented your op is to write a
test for it. Create the file
<cite>zero_out_op_test.py</cite> with the contents:</p>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>python
import tensorflow as tf</p>
<dl>
<dt>class ZeroOutTest(tf.test.TestCase):</dt><dd><dl>
<dt>def testZeroOut(self):</dt><dd><p>zero_out_module = tf.load_op_library(“./zero_out.so”)
with self.test_session():</p>
<blockquote>
<div><p>result = zero_out_module.zero_out([5, 4, 3, 2, 1])
self.assertAllEqual(result.eval(), [5, 0, 0, 0, 0])</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>if __name__ == «__main__»:</dt><dd><p>tf.test.main()</p>
</dd>
</dl>
<p><a href="#id70"><span class="problematic" id="id71">``</span></a><a href="#id72"><span class="problematic" id="id73">`</span></a></p>
<p>Then run your test (assuming you have tensorflow installed):</p>
<p><code class="docutils literal notranslate"><span class="pre">`sh</span>
<span class="pre">$</span> <span class="pre">python</span> <span class="pre">zero_out_op_test.py</span>
<span class="pre">`</span></code></p>
<p>## Build advanced features into your op</p>
<p>Now that you know how to build a basic (and somewhat restricted) op and
implementation, we’ll look at some of the more complicated things you will
typically need to build into your op. This includes:</p>
<ul class="simple">
<li><p>[Conditional checks and validation](#conditional-checks-and-validation)</p></li>
<li><p>[Op registration](#op-registration)
*   [Attrs](#attrs)
*   [Attr types](#attr-types)
*   [Polymorphism](#polymorphism)
*   [Inputs and outputs](#inputs-and-outputs)
*   [Backwards compatibility](#backwards-compatibility)</p></li>
<li><p>[GPU support](#gpu-support)
*   [Compiling the kernel for the GPU device](#compiling-the-kernel-for-the-gpu-device)</p></li>
<li><p>[Implement the gradient in Python](#implement-the-gradient-in-python)</p></li>
<li><p>[Shape functions in C++](#shape-functions-in-c)</p></li>
</ul>
<p>### Conditional checks and validation</p>
<p>The example above assumed that the op applied to a tensor of any shape.  What
if it only applied to vectors?  That means adding a check to the above OpKernel
implementation.</p>
<dl>
<dt><a href="#id74"><span class="problematic" id="id75">``</span></a><a href="#id76"><span class="problematic" id="id77">`</span></a>c++</dt><dd><dl>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// Grab the input tensor
const Tensor&amp; input_tensor = context-&gt;input(0);</p>
<dl class="simple">
<dt>OP_REQUIRES(context, TensorShapeUtils::IsVector(input_tensor.shape()),</dt><dd><p>errors::InvalidArgument(«ZeroOut expects a 1-D vector.»));</p>
</dd>
</dl>
<p>// …</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p><a href="#id78"><span class="problematic" id="id79">``</span></a><a href="#id80"><span class="problematic" id="id81">`</span></a></p>
<p>This asserts that the input is a vector, and returns having set the
<cite>InvalidArgument</cite> status if it isn’t.  The
[<cite>OP_REQUIRES</cite> macro][validation-macros] takes three arguments:</p>
<ul class="simple">
<li><p>The <cite>context</cite>, which can either be an <cite>OpKernelContext</cite> or
<cite>OpKernelConstruction</cite> pointer (see
[<cite>tensorflow/core/framework/op_kernel.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/op_kernel.h">https://www.tensorflow.org/code/tensorflow/core/framework/op_kernel.h</a>)),
for its <cite>SetStatus()</cite> method.</p></li>
<li><p>The condition.  For example, there are functions for validating the shape
of a tensor in
[<cite>tensorflow/core/framework/tensor_shape.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/tensor_shape.h">https://www.tensorflow.org/code/tensorflow/core/framework/tensor_shape.h</a>)</p></li>
<li><p>The error itself, which is represented by a <cite>Status</cite> object, see
[<cite>tensorflow/core/lib/core/status.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/lib/core/status.h">https://www.tensorflow.org/code/tensorflow/core/lib/core/status.h</a>). A
<cite>Status</cite> has both a type (frequently <cite>InvalidArgument</cite>, but see the list of
types) and a message.  Functions for constructing an error may be found in
[<cite>tensorflow/core/lib/core/errors.h</cite>][validation-macros].</p></li>
</ul>
<p>Alternatively, if you want to test whether a <cite>Status</cite> object returned from some
function is an error, and if so return it, use
[<cite>OP_REQUIRES_OK</cite>][validation-macros].  Both of these macros return from the
function on error.</p>
<p>### Op registration</p>
<p>#### Attrs</p>
<p>Ops can have attrs, whose values are set when the op is added to a graph. These
are used to configure the op, and their values can be accessed both within the
kernel implementation and in the types of inputs and outputs in the op
registration. Prefer using an input instead of an attr when possible, since
inputs are more flexible. This is because attrs are constants and must be
defined at graph construction time. In contrast, inputs are Tensors whose
values can be dynamic; that is, inputs can change every step, be set using a
feed, etc. Attrs are used for things that can’t be done with inputs: any
configuration that affects the signature (number or type of inputs or outputs)
or that can’t change from step-to-step.</p>
<p>You define an attr when you register the op, by specifying its name and type
using the <cite>Attr</cite> method, which expects a spec of the form:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&lt;name&gt;:</span> <span class="pre">&lt;attr-type-expr&gt;</span>
<span class="pre">`</span></code></p>
<p>where <cite>&lt;name&gt;</cite> begins with a letter and can be composed of alphanumeric
characters and underscores, and <cite>&lt;attr-type-expr&gt;</cite> is a type expression of the
form [described below](#attr-types).</p>
<p>For example, if you’d like the <cite>ZeroOut</cite> op to preserve a user-specified index,
instead of only the 0th element, you can register the op like so:</p>
<p><a href="#id82"><span class="problematic" id="id83">``</span></a><a href="#id84"><span class="problematic" id="id85">`</span></a>c++
REGISTER_OP(«ZeroOut»)</p>
<blockquote>
<div><p>.Attr(«preserve_index: int»)
.Input(«to_zero: int32»)
.Output(«zeroed: int32»);</p>
</div></blockquote>
<p><a href="#id86"><span class="problematic" id="id87">``</span></a><a href="#id88"><span class="problematic" id="id89">`</span></a></p>
<p>(Note that the set of [attribute types](#attr-types) is different from the
<cite>tf.DType</cite> used for inputs and outputs.)</p>
<p>Your kernel can then access this attr in its constructor via the <cite>context</cite>
parameter:</p>
<p><a href="#id90"><span class="problematic" id="id91">``</span></a><a href="#id92"><span class="problematic" id="id93">`</span></a>c++
class ZeroOutOp : public OpKernel {</p>
<blockquote>
<div><dl>
<dt>public:</dt><dd><dl>
<dt>explicit ZeroOutOp(OpKernelConstruction* context)<span class="classifier">OpKernel(context) {</span></dt><dd><p>// Get the index of the value to preserve
OP_REQUIRES_OK(context,</p>
<blockquote>
<div><p>context-&gt;GetAttr(«preserve_index», &amp;preserve_index_));</p>
</div></blockquote>
<p>// Check that preserve_index is positive
OP_REQUIRES(context, <a href="#id440"><span class="problematic" id="id441">preserve_index_</span></a> &gt;= 0,</p>
<blockquote>
<div><dl class="simple">
<dt>errors::InvalidArgument(«Need preserve_index &gt;= 0, got «,</dt><dd><p><a href="#id442"><span class="problematic" id="id443">preserve_index_</span></a>));</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}
void Compute(OpKernelContext* context) override {</p>
<blockquote>
<div><p>// …</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>private:</dt><dd><p>int <a href="#id444"><span class="problematic" id="id445">preserve_index_</span></a>;</p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="id94">
<h1>};<a class="headerlink" href="#id94" title="Enlazar permanentemente con este título">¶</a></h1>
<p>which can then be used in the <cite>Compute</cite> method:</p>
<dl>
<dt><a href="#id95"><span class="problematic" id="id96">``</span></a><a href="#id97"><span class="problematic" id="id98">`</span></a>c++</dt><dd><dl>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// …</p>
<p>// We’re using saved attr to validate potentially dynamic input
// So we check that preserve_index is in range
OP_REQUIRES(context, <a href="#id446"><span class="problematic" id="id447">preserve_index_</span></a> &lt; input.dimension(0),</p>
<blockquote>
<div><p>errors::InvalidArgument(«preserve_index out of range»));</p>
</div></blockquote>
<p>// Set all the elements of the output tensor to 0
const int N = input.size();
for (int i = 0; i &lt; N; i++) {</p>
<blockquote>
<div><p>output_flat(i) = 0;</p>
</div></blockquote>
<p>}</p>
<p>// Preserve the requested input value
output_flat(<a href="#id448"><span class="problematic" id="id449">preserve_index_</span></a>) = input(<a href="#id450"><span class="problematic" id="id451">preserve_index_</span></a>);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p><a href="#id99"><span class="problematic" id="id100">``</span></a><a href="#id101"><span class="problematic" id="id102">`</span></a></p>
<p>#### Attr types</p>
<p>The following types are supported in an attr:</p>
<ul class="simple">
<li><p><cite>string</cite>: Any sequence of bytes (not required to be UTF8).</p></li>
<li><p><cite>int</cite>: A signed integer.</p></li>
<li><p><cite>float</cite>: A floating point number.</p></li>
<li><p><cite>bool</cite>: True or false.</p></li>
<li><p><cite>type</cite>: One of the (non-ref) values of [<cite>DataType</cite>][DataTypeString].</p></li>
<li><p><cite>shape</cite>: A [<cite>TensorShapeProto</cite>][TensorShapeProto].</p></li>
<li><p><cite>list(&lt;type&gt;)</cite>: A list of <cite>&lt;type&gt;</cite>, where <cite>&lt;type&gt;</cite> is one of the above types.
Note that <cite>list(list(&lt;type&gt;))</cite> is invalid.</p></li>
</ul>
<p>See also: [<cite>op_def_builder.cc:FinalizeAttr</cite>][FinalizeAttr] for a definitive list.</p>
<p>##### Default values and constraints</p>
<p>Attrs may have default values, and some types of attrs can have constraints. To
define an attr with constraints, you can use the following <a href="#id103"><span class="problematic" id="id104">`</span></a>&lt;attr-type-expr&gt;`s:</p>
<p><cite>{“&lt;string1&gt;”, “&lt;string2&gt;”}</cite>: The value must be a string that has either the
value <cite>&lt;string1&gt;</cite> or <cite>&lt;string2&gt;</cite>. The name of the type, <cite>string</cite>, is implied
when you use this syntax. This emulates an enum:</p>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a>c++
REGISTER_OP(«EnumExample»)</p>
<blockquote>
<div><p>.Attr(«e: {“apple”, “orange”}»);</p>
</div></blockquote>
<p><a href="#id109"><span class="problematic" id="id110">``</span></a><a href="#id111"><span class="problematic" id="id112">`</span></a></p>
<p><cite>{&lt;type1&gt;, &lt;type2&gt;}</cite>: The value is of type <cite>type</cite>, and must be one of <cite>&lt;type1&gt;</cite>
or <cite>&lt;type2&gt;</cite>, where <cite>&lt;type1&gt;</cite> and <cite>&lt;type2&gt;</cite> are supported <cite>tf.DType</cite>. You don’t
specify that the type of the attr is <cite>type</cite>. This is implied when you have a
list of types in <cite>{…}</cite>. For example, in this case the attr <cite>t</cite> is a type that
must be an <cite>int32</cite>, a <cite>float</cite>, or a <cite>bool</cite>:</p>
<p><a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a>c++
REGISTER_OP(«RestrictedTypeExample»)</p>
<blockquote>
<div><p>.Attr(«t: {int32, float, bool}»);</p>
</div></blockquote>
<p><a href="#id117"><span class="problematic" id="id118">``</span></a><a href="#id119"><span class="problematic" id="id120">`</span></a></p>
<p>There are shortcuts for common type constraints:</p>
<ul class="simple">
<li><p><cite>numbertype</cite>: Type <cite>type</cite> restricted to the numeric (non-string and
non-bool) types.</p></li>
<li><p><cite>realnumbertype</cite>: Like <cite>numbertype</cite> without complex types.</p></li>
<li><p><cite>quantizedtype</cite>: Like <cite>numbertype</cite> but just the quantized number types.</p></li>
</ul>
<p>The specific lists of types allowed by these are defined by the functions (like
<cite>NumberTypes()</cite>) in
[<cite>tensorflow/core/framework/types.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/types.h">https://www.tensorflow.org/code/tensorflow/core/framework/types.h</a>).
In this example the attr <cite>t</cite> must be one of the numeric types:</p>
<p><a href="#id121"><span class="problematic" id="id122">``</span></a><a href="#id123"><span class="problematic" id="id124">`</span></a>c++
REGISTER_OP(«NumberType»)</p>
<blockquote>
<div><p>.Attr(«t: numbertype»);</p>
</div></blockquote>
<p><a href="#id125"><span class="problematic" id="id126">``</span></a><a href="#id127"><span class="problematic" id="id128">`</span></a></p>
<p>For this op:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">tf.number_type(t=tf.int32)</span>&#160; <span class="pre">#</span> <span class="pre">Valid</span>
<span class="pre">tf.number_type(t=tf.bool)</span>&#160;&#160; <span class="pre">#</span> <span class="pre">Invalid</span>
<span class="pre">`</span></code></p>
<p>Lists can be combined with other lists and single types. The following op allows
attr <cite>t</cite> to be any of the numeric types, or the bool type:</p>
<p><a href="#id129"><span class="problematic" id="id130">``</span></a><a href="#id131"><span class="problematic" id="id132">`</span></a>c++
REGISTER_OP(«NumberOrBooleanType»)</p>
<blockquote>
<div><p>.Attr(«t: {numbertype, bool}»);</p>
</div></blockquote>
<p><a href="#id133"><span class="problematic" id="id134">``</span></a><a href="#id135"><span class="problematic" id="id136">`</span></a></p>
<p>For this op:</p>
<p><code class="docutils literal notranslate"><span class="pre">`python</span>
<span class="pre">tf.number_or_boolean_type(t=tf.int32)</span>&#160; <span class="pre">#</span> <span class="pre">Valid</span>
<span class="pre">tf.number_or_boolean_type(t=tf.bool)</span>&#160;&#160; <span class="pre">#</span> <span class="pre">Valid</span>
<span class="pre">tf.number_or_boolean_type(t=tf.string)</span> <span class="pre">#</span> <span class="pre">Invalid</span>
<span class="pre">`</span></code></p>
<p><cite>int &gt;= &lt;n&gt;</cite>: The value must be an int whose value is greater than or equal to
<cite>&lt;n&gt;</cite>, where <cite>&lt;n&gt;</cite> is a natural number. For example, the following op
registration specifies that the attr <cite>a</cite> must have a value that is at least <cite>2</cite>:</p>
<p><a href="#id137"><span class="problematic" id="id138">``</span></a><a href="#id139"><span class="problematic" id="id140">`</span></a>c++
REGISTER_OP(«MinIntExample»)</p>
<blockquote>
<div><p>.Attr(«a: int &gt;= 2»);</p>
</div></blockquote>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<p><cite>list(&lt;type&gt;) &gt;= &lt;n&gt;</cite>: A list of type <cite>&lt;type&gt;</cite> whose length is greater than or
equal to <cite>&lt;n&gt;</cite>. For example, the following op registration specifies that the
attr <cite>a</cite> is a list of types (either <cite>int32</cite> or <cite>float</cite>), and that there must be
at least 3 of them:</p>
<p><a href="#id145"><span class="problematic" id="id146">``</span></a><a href="#id147"><span class="problematic" id="id148">`</span></a>c++
REGISTER_OP(«TypeListExample»)</p>
<blockquote>
<div><p>.Attr(«a: list({int32, float}) &gt;= 3»);</p>
</div></blockquote>
<p><a href="#id149"><span class="problematic" id="id150">``</span></a><a href="#id151"><span class="problematic" id="id152">`</span></a></p>
<p>To set a default value for an attr (making it optional in the generated code),
add <cite>= &lt;default&gt;</cite> to the end, as in:</p>
<p><a href="#id153"><span class="problematic" id="id154">``</span></a><a href="#id155"><span class="problematic" id="id156">`</span></a>c++
REGISTER_OP(«AttrDefaultExample»)</p>
<blockquote>
<div><p>.Attr(«i: int = 0»);</p>
</div></blockquote>
<p><a href="#id157"><span class="problematic" id="id158">``</span></a><a href="#id159"><span class="problematic" id="id160">`</span></a></p>
<p>Additionally, both a constraint and a default value can be specified:</p>
<p><a href="#id161"><span class="problematic" id="id162">``</span></a><a href="#id163"><span class="problematic" id="id164">`</span></a>c++
REGISTER_OP(«AttrConstraintAndDefaultExample»)</p>
<blockquote>
<div><p>.Attr(«i: int &gt;= 1 = 1»);</p>
</div></blockquote>
<p><a href="#id165"><span class="problematic" id="id166">``</span></a><a href="#id167"><span class="problematic" id="id168">`</span></a></p>
<p>The supported syntax of the default value is what would be used in the proto
representation of the resulting GraphDef definition.</p>
<p>Here are examples for how to specify a default for all types:</p>
<p><a href="#id169"><span class="problematic" id="id170">``</span></a><a href="#id171"><span class="problematic" id="id172">`</span></a>c++
REGISTER_OP(«AttrDefaultExampleForAllTypes»)</p>
<blockquote>
<div><p>.Attr(«s: string = “foo”»)
.Attr(«i: int = 0»)
.Attr(«f: float = 1.0»)
.Attr(«b: bool = true»)
.Attr(«ty: type = DT_INT32»)
.Attr(«sh: shape = { dim { size: 1 } dim { size: 2 } }»)
.Attr(«te: tensor = { dtype: DT_INT32 int_val: 5 }»)
.Attr(«l_empty: list(int) = []»)
.Attr(«l_int: list(int) = [2, 3, 5, 7]»);</p>
</div></blockquote>
<p><a href="#id173"><span class="problematic" id="id174">``</span></a><a href="#id175"><span class="problematic" id="id176">`</span></a></p>
<p>Note in particular that the values of type <cite>type</cite>
use <cite>tf.DType</cite>.</p>
<p>#### Polymorphism</p>
<p>##### Type polymorphism</p>
<p>For ops that can take different types as input or produce different output
types, you can specify [an attr](#attrs) in
[an input or output type](#inputs-and-outputs) in the op registration.  Typically
you would then register an <cite>OpKernel</cite> for each supported type.</p>
<p>For instance, if you’d like the <cite>ZeroOut</cite> op to work on <a href="#id177"><span class="problematic" id="id178">`</span></a>float`s
in addition to <a href="#id179"><span class="problematic" id="id180">`</span></a>int32`s, your op registration might look like:</p>
<p><a href="#id181"><span class="problematic" id="id182">``</span></a><a href="#id183"><span class="problematic" id="id184">`</span></a>c++
REGISTER_OP(«ZeroOut»)</p>
<blockquote>
<div><p>.Attr(«T: {float, int32}»)
.Input(«to_zero: T»)
.Output(«zeroed: T»);</p>
</div></blockquote>
<p><a href="#id185"><span class="problematic" id="id186">``</span></a><a href="#id187"><span class="problematic" id="id188">`</span></a></p>
<p>Your op registration now specifies that the input’s type must be <cite>float</cite>, or
<cite>int32</cite>, and that its output will be the same type, since both have type <cite>T</cite>.</p>
<p>###### Naming</p>
<p>Inputs, outputs, and attrs generally should be given snake_case names. The one
exception is attrs that are used as the type of an input or in the type of an
output. Those attrs can be inferred when the op is added to the graph and so
don’t appear in the op’s function. For example, this last definition of ZeroOut
will generate a Python function that looks like:</p>
<p><a href="#id189"><span class="problematic" id="id190">``</span></a><a href="#id191"><span class="problematic" id="id192">`</span></a>python
def zero_out(to_zero, name=None):</p>
<blockquote>
<div><p>«»»…
Args:</p>
<blockquote>
<div><dl class="simple">
<dt>to_zero: A <cite>Tensor</cite>. Must be one of the following types:</dt><dd><p><cite>float32</cite>, <cite>int32</cite>.</p>
</dd>
</dl>
<p>name: A name for the operation (optional).</p>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>A <cite>Tensor</cite>. Has the same type as <cite>to_zero</cite>.</p>
</dd>
</dl>
<p>«»»</p>
</div></blockquote>
<p><a href="#id193"><span class="problematic" id="id194">``</span></a><a href="#id195"><span class="problematic" id="id196">`</span></a></p>
<p>If <cite>to_zero</cite> is passed an <cite>int32</cite> tensor, then <cite>T</cite> is automatically set to
<cite>int32</cite> (well, actually <cite>DT_INT32</cite>). Those inferred attrs are given Capitalized
or CamelCase names.</p>
<p>Compare this with an op that has a type attr that determines the output type:</p>
<p><a href="#id197"><span class="problematic" id="id198">``</span></a><a href="#id199"><span class="problematic" id="id200">`</span></a>c++
REGISTER_OP(«StringToNumber»)</p>
<blockquote>
<div><p>.Input(«string_tensor: string»)
.Output(«output: out_type»)
.Attr(«out_type: {float, int32} = DT_FLOAT»);
.Doc(R»doc(</p>
</div></blockquote>
<p>Converts each string in the input Tensor to the specified numeric type.
)doc»);
<a href="#id201"><span class="problematic" id="id202">``</span></a><a href="#id203"><span class="problematic" id="id204">`</span></a></p>
<p>In this case, the user has to specify the output type, as in the generated
Python:</p>
<p><a href="#id205"><span class="problematic" id="id206">``</span></a><a href="#id207"><span class="problematic" id="id208">`</span></a>python
def string_to_number(string_tensor, out_type=None, name=None):</p>
<blockquote>
<div><p>«»»Converts each string in the input Tensor to the specified numeric type.</p>
<dl>
<dt>Args:</dt><dd><p>string_tensor: A <cite>Tensor</cite> of type <cite>string</cite>.
out_type: An optional <cite>tf.DType</cite> from: <cite>tf.float32, tf.int32</cite>.</p>
<blockquote>
<div><p>Defaults to <cite>tf.float32</cite>.</p>
</div></blockquote>
<p>name: A name for the operation (optional).</p>
</dd>
<dt>Returns:</dt><dd><p>A <cite>Tensor</cite> of type <cite>out_type</cite>.</p>
</dd>
</dl>
<p>«»»</p>
</div></blockquote>
<p><a href="#id209"><span class="problematic" id="id210">``</span></a><a href="#id211"><span class="problematic" id="id212">`</span></a></p>
<p>###### Type polymorphism example</p>
<p><a href="#id213"><span class="problematic" id="id214">``</span></a><a href="#id215"><span class="problematic" id="id216">`</span></a>c++
#include «tensorflow/core/framework/op_kernel.h»</p>
<dl class="simple">
<dt>class ZeroOutInt32Op<span class="classifier">public OpKernel {</span></dt><dd><p>// as before</p>
</dd>
</dl>
<p>};</p>
<dl>
<dt>class ZeroOutFloatOp<span class="classifier">public OpKernel {</span></dt><dd><dl>
<dt>public:</dt><dd><dl>
<dt>explicit ZeroOutFloatOp(OpKernelConstruction* context)</dt><dd><p>: OpKernel(context) {}</p>
</dd>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// Grab the input tensor
const Tensor&amp; input_tensor = context-&gt;input(0);
auto input = input_tensor.flat&lt;float&gt;();</p>
<p>// Create an output tensor
Tensor* output = NULL;
OP_REQUIRES_OK(context,</p>
<blockquote>
<div><p>context-&gt;allocate_output(0, input_tensor.shape(), &amp;output));</p>
</div></blockquote>
<p>auto output_flat = output-&gt;template flat&lt;float&gt;();</p>
<p>// Set all the elements of the output tensor to 0
const int N = input.size();
for (int i = 0; i &lt; N; i++) {</p>
<blockquote>
<div><p>output_flat(i) = 0;</p>
</div></blockquote>
<p>}</p>
<p>// Preserve the first input value
if (N &gt; 0) output_flat(0) = input(0);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>};</p>
<p>// Note that TypeConstraint&lt;int32&gt;(«T») means that attr «T» (defined
// in the op registration above) must be «int32» to use this template
// instantiation.
REGISTER_KERNEL_BUILDER(</p>
<blockquote>
<div><p>Name(«ZeroOut»)
.Device(DEVICE_CPU)
.TypeConstraint&lt;int32&gt;(«T»),
ZeroOutInt32Op);</p>
</div></blockquote>
<dl class="simple">
<dt>REGISTER_KERNEL_BUILDER(</dt><dd><p>Name(«ZeroOut»)
.Device(DEVICE_CPU)
.TypeConstraint&lt;float&gt;(«T»),
ZeroOutFloatOp);</p>
</dd>
</dl>
<p><a href="#id217"><span class="problematic" id="id218">``</span></a><a href="#id219"><span class="problematic" id="id220">`</span></a></p>
<p>To preserve [backwards compatibility](#backwards-compatibility), you should
specify a [default value](#default-values-and-constraints) when adding an attr
to an existing op:</p>
<p><a href="#id221"><span class="problematic" id="id222">``</span></a><a href="#id223"><span class="problematic" id="id224">`</span></a>c++
REGISTER_OP(«ZeroOut»)</p>
<blockquote>
<div><p>.Attr(«T: {float, int32} = DT_INT32»)
.Input(«to_zero: T»)
.Output(«zeroed: T»)</p>
</div></blockquote>
<p><a href="#id225"><span class="problematic" id="id226">``</span></a><a href="#id227"><span class="problematic" id="id228">`</span></a></p>
<p>Let’s say you wanted to add more types, say <cite>double</cite>:</p>
<p><a href="#id229"><span class="problematic" id="id230">``</span></a><a href="#id231"><span class="problematic" id="id232">`</span></a>c++
REGISTER_OP(«ZeroOut»)</p>
<blockquote>
<div><p>.Attr(«T: {float, double, int32}»)
.Input(«to_zero: T»)
.Output(«zeroed: T»);</p>
</div></blockquote>
<p><a href="#id233"><span class="problematic" id="id234">``</span></a><a href="#id235"><span class="problematic" id="id236">`</span></a></p>
<p>Instead of writing another <cite>OpKernel</cite> with redundant code as above, often you
will be able to use a C++ template instead.  You will still have one kernel
registration (<cite>REGISTER_KERNEL_BUILDER</cite> call) per overload.</p>
<p><a href="#id237"><span class="problematic" id="id238">``</span></a><a href="#id239"><span class="problematic" id="id240">`</span></a>c++
template &lt;typename T&gt;
class ZeroOutOp : public OpKernel {</p>
<blockquote>
<div><dl>
<dt>public:</dt><dd><p>explicit ZeroOutOp(OpKernelConstruction* context) : OpKernel(context) {}</p>
<dl>
<dt>void Compute(OpKernelContext* context) override {</dt><dd><p>// Grab the input tensor
const Tensor&amp; input_tensor = context-&gt;input(0);
auto input = input_tensor.flat&lt;T&gt;();</p>
<p>// Create an output tensor
Tensor* output = NULL;
OP_REQUIRES_OK(context,</p>
<blockquote>
<div><p>context-&gt;allocate_output(0, input_tensor.shape(), &amp;output));</p>
</div></blockquote>
<p>auto output_flat = output-&gt;template flat&lt;T&gt;();</p>
<p>// Set all the elements of the output tensor to 0
const int N = input.size();
for (int i = 0; i &lt; N; i++) {</p>
<blockquote>
<div><p>output_flat(i) = 0;</p>
</div></blockquote>
<p>}</p>
<p>// Preserve the first input value
if (N &gt; 0) output_flat(0) = input(0);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>};</p>
<p>// Note that TypeConstraint&lt;int32&gt;(«T») means that attr «T» (defined
// in the op registration above) must be «int32» to use this template
// instantiation.
REGISTER_KERNEL_BUILDER(</p>
<blockquote>
<div><p>Name(«ZeroOut»)
.Device(DEVICE_CPU)
.TypeConstraint&lt;int32&gt;(«T»),
ZeroOutOp&lt;int32&gt;);</p>
</div></blockquote>
<dl class="simple">
<dt>REGISTER_KERNEL_BUILDER(</dt><dd><p>Name(«ZeroOut»)
.Device(DEVICE_CPU)
.TypeConstraint&lt;float&gt;(«T»),
ZeroOutOp&lt;float&gt;);</p>
</dd>
<dt>REGISTER_KERNEL_BUILDER(</dt><dd><p>Name(«ZeroOut»)
.Device(DEVICE_CPU)
.TypeConstraint&lt;double&gt;(«T»),
ZeroOutOp&lt;double&gt;);</p>
</dd>
</dl>
<p><a href="#id241"><span class="problematic" id="id242">``</span></a><a href="#id243"><span class="problematic" id="id244">`</span></a></p>
<p>If you have more than a couple overloads, you can put the registration in a
macro.</p>
<p><a href="#id245"><span class="problematic" id="id246">``</span></a><a href="#id247"><span class="problematic" id="id248">`</span></a>c++
#include «tensorflow/core/framework/op_kernel.h»</p>
<dl class="simple">
<dt>#define REGISTER_KERNEL(type)                                       </dt><dd><dl class="simple">
<dt>REGISTER_KERNEL_BUILDER(                                          </dt><dd><p>Name(«ZeroOut»).Device(DEVICE_CPU).TypeConstraint&lt;type&gt;(«T»), ZeroOutOp&lt;type&gt;)</p>
</dd>
</dl>
</dd>
</dl>
<p>REGISTER_KERNEL(int32);
REGISTER_KERNEL(float);
REGISTER_KERNEL(double);</p>
<p>#undef REGISTER_KERNEL
<a href="#id249"><span class="problematic" id="id250">``</span></a><a href="#id251"><span class="problematic" id="id252">`</span></a></p>
<p>Depending on the list of types you are registering the kernel for, you may be
able to use a macro provided by
[<cite>tensorflow/core/framework/register_types.h</cite>][register_types]:</p>
<p><a href="#id253"><span class="problematic" id="id254">``</span></a><a href="#id255"><span class="problematic" id="id256">`</span></a>c++
#include «tensorflow/core/framework/op_kernel.h»
#include «tensorflow/core/framework/register_types.h»</p>
<dl class="simple">
<dt>REGISTER_OP(«ZeroOut»)</dt><dd><p>.Attr(«T: realnumbertype»)
.Input(«to_zero: T»)
.Output(«zeroed: T»);</p>
</dd>
</dl>
<p>template &lt;typename T&gt;
class ZeroOutOp : public OpKernel { … };</p>
<dl class="simple">
<dt>#define REGISTER_KERNEL(type)                                       </dt><dd><dl class="simple">
<dt>REGISTER_KERNEL_BUILDER(                                          </dt><dd><p>Name(«ZeroOut»).Device(DEVICE_CPU).TypeConstraint&lt;type&gt;(«T»), ZeroOutOp&lt;type&gt;)</p>
</dd>
</dl>
</dd>
</dl>
<p>TF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNEL);</p>
<p>#undef REGISTER_KERNEL
<a href="#id257"><span class="problematic" id="id258">``</span></a><a href="#id259"><span class="problematic" id="id260">`</span></a></p>
<p>##### List inputs and outputs</p>
<p>In addition to being able to accept or produce different types, ops can consume
or produce a variable number of tensors.</p>
<p>In the next example, the attr <cite>T</cite> holds a <em>list</em> of types, and is used as the
type of both the input <cite>in</cite> and the output <cite>out</cite>.  The input and output are
lists of tensors of that type (and the number and types of tensors in the output
are the same as the input, since both have type <cite>T</cite>).</p>
<p><a href="#id261"><span class="problematic" id="id262">``</span></a><a href="#id263"><span class="problematic" id="id264">`</span></a>c++
REGISTER_OP(«PolymorphicListExample»)</p>
<blockquote>
<div><p>.Attr(«T: list(type)»)
.Input(«in: T»)
.Output(«out: T»);</p>
</div></blockquote>
<p><a href="#id265"><span class="problematic" id="id266">``</span></a><a href="#id267"><span class="problematic" id="id268">`</span></a></p>
<p>You can also place restrictions on what types can be specified in the list. In
this next case, the input is a list of <cite>float</cite> and <cite>double</cite> tensors. The op
accepts, for example, input types <cite>(float, double, float)</cite> and in that case the
output type would also be <cite>(float, double, float)</cite>.</p>
<p><a href="#id269"><span class="problematic" id="id270">``</span></a><a href="#id271"><span class="problematic" id="id272">`</span></a>c++
REGISTER_OP(«ListTypeRestrictionExample»)</p>
<blockquote>
<div><p>.Attr(«T: list({float, double})»)
.Input(«in: T»)
.Output(«out: T»);</p>
</div></blockquote>
<p><a href="#id273"><span class="problematic" id="id274">``</span></a><a href="#id275"><span class="problematic" id="id276">`</span></a></p>
<p>If you want all the tensors in a list to be of the same type, you might do
something like:</p>
<p><a href="#id277"><span class="problematic" id="id278">``</span></a><a href="#id279"><span class="problematic" id="id280">`</span></a>c++
REGISTER_OP(«IntListInputExample»)</p>
<blockquote>
<div><p>.Attr(«N: int»)
.Input(«in: N * int32»)
.Output(«out: int32»);</p>
</div></blockquote>
<p><a href="#id281"><span class="problematic" id="id282">``</span></a><a href="#id283"><span class="problematic" id="id284">`</span></a></p>
<p>This accepts a list of <cite>int32</cite> tensors, and uses an <cite>int</cite> attr <cite>N</cite> to
specify the length of the list.</p>
<p>This can be made [type polymorphic](#type-polymorphism) as well.  In the next
example, the input is a list of tensors (with length <cite>«N»</cite>) of the same (but
unspecified) type (<cite>«T»</cite>), and the output is a single tensor of matching type:</p>
<p><a href="#id285"><span class="problematic" id="id286">``</span></a><a href="#id287"><span class="problematic" id="id288">`</span></a>c++
REGISTER_OP(«SameListInputExample»)</p>
<blockquote>
<div><p>.Attr(«N: int»)
.Attr(«T: type»)
.Input(«in: N * T»)
.Output(«out: T»);</p>
</div></blockquote>
<p><a href="#id289"><span class="problematic" id="id290">``</span></a><a href="#id291"><span class="problematic" id="id292">`</span></a></p>
<p>By default, tensor lists have a minimum length of 1. You can change that default
using
[a <cite>«&gt;=»</cite> constraint on the corresponding attr](#default-values-and-constraints).
In this next example, the input is a list of at least 2 <cite>int32</cite> tensors:</p>
<p><a href="#id293"><span class="problematic" id="id294">``</span></a><a href="#id295"><span class="problematic" id="id296">`</span></a>c++
REGISTER_OP(«MinLengthIntListExample»)</p>
<blockquote>
<div><p>.Attr(«N: int &gt;= 2»)
.Input(«in: N * int32»)
.Output(«out: int32»);</p>
</div></blockquote>
<p><a href="#id297"><span class="problematic" id="id298">``</span></a><a href="#id299"><span class="problematic" id="id300">`</span></a></p>
<p>The same syntax works with <cite>«list(type)»</cite> attrs:</p>
<p><a href="#id301"><span class="problematic" id="id302">``</span></a><a href="#id303"><span class="problematic" id="id304">`</span></a>c++
REGISTER_OP(«MinimumLengthPolymorphicListExample»)</p>
<blockquote>
<div><p>.Attr(«T: list(type) &gt;= 3»)
.Input(«in: T»)
.Output(«out: T»);</p>
</div></blockquote>
<p><a href="#id305"><span class="problematic" id="id306">``</span></a><a href="#id307"><span class="problematic" id="id308">`</span></a></p>
<p>#### Inputs and outputs</p>
<p>To summarize the above, an op registration can have multiple inputs and outputs:</p>
<p><a href="#id309"><span class="problematic" id="id310">``</span></a><a href="#id311"><span class="problematic" id="id312">`</span></a>c++
REGISTER_OP(«MultipleInsAndOuts»)</p>
<blockquote>
<div><p>.Input(«y: int32»)
.Input(«z: float»)
.Output(«a: string»)
.Output(«b: int32»);</p>
</div></blockquote>
<p><a href="#id313"><span class="problematic" id="id314">``</span></a><a href="#id315"><span class="problematic" id="id316">`</span></a></p>
<p>Each input or output spec is of the form:</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">&lt;name&gt;:</span> <span class="pre">&lt;io-type-expr&gt;</span>
<span class="pre">`</span></code></p>
<p>where <cite>&lt;name&gt;</cite> begins with a letter and can be composed of alphanumeric
characters and underscores. <cite>&lt;io-type-expr&gt;</cite> is one of the following type
expressions:</p>
<ul>
<li><p><cite>&lt;type&gt;</cite>, where <cite>&lt;type&gt;</cite> is a supported input type (e.g. <cite>float</cite>, <cite>int32</cite>,
<cite>string</cite>). This specifies a single tensor of the given type.</p>
<p>See
<cite>tf.DType</cite>.</p>
<p><a href="#id317"><span class="problematic" id="id318">``</span></a><a href="#id319"><span class="problematic" id="id320">`</span></a>c++
REGISTER_OP(«BuiltInTypesExample»)</p>
<blockquote>
<div><p>.Input(«integers: int32»)
.Input(«complex_numbers: complex64»);</p>
</div></blockquote>
<p><a href="#id321"><span class="problematic" id="id322">``</span></a><a href="#id323"><span class="problematic" id="id324">`</span></a></p>
</li>
<li><p><cite>&lt;attr-type&gt;</cite>, where <cite>&lt;attr-type&gt;</cite> is the name of an [Attr](#attrs) with type
<cite>type</cite> or <cite>list(type)</cite> (with a possible type restriction). This syntax allows
for [polymorphic ops](#polymorphism).</p>
<p><a href="#id325"><span class="problematic" id="id326">``</span></a><a href="#id327"><span class="problematic" id="id328">`</span></a>c++
REGISTER_OP(«PolymorphicSingleInput»)</p>
<blockquote>
<div><p>.Attr(«T: type»)
.Input(«in: T»);</p>
</div></blockquote>
<dl class="simple">
<dt>REGISTER_OP(«RestrictedPolymorphicSingleInput»)</dt><dd><p>.Attr(«T: {int32, int64}»)
.Input(«in: T»);</p>
</dd>
</dl>
<p><a href="#id329"><span class="problematic" id="id330">``</span></a><a href="#id331"><span class="problematic" id="id332">`</span></a></p>
<p>Referencing an attr of type <cite>list(type)</cite> allows you to accept a sequence of
tensors.</p>
<p><a href="#id333"><span class="problematic" id="id334">``</span></a><a href="#id335"><span class="problematic" id="id336">`</span></a>c++
REGISTER_OP(«ArbitraryTensorSequenceExample»)</p>
<blockquote>
<div><p>.Attr(«T: list(type)»)
.Input(«in: T»)
.Output(«out: T»);</p>
</div></blockquote>
<dl class="simple">
<dt>REGISTER_OP(«RestrictedTensorSequenceExample»)</dt><dd><p>.Attr(«T: list({int32, int64})»)
.Input(«in: T»)
.Output(«out: T»);</p>
</dd>
</dl>
<p><a href="#id337"><span class="problematic" id="id338">``</span></a><a href="#id339"><span class="problematic" id="id340">`</span></a></p>
<p>Note that the number and types of tensors in the output <cite>out</cite> is the same as
in the input <cite>in</cite>, since both are of type <cite>T</cite>.</p>
</li>
<li><p>For a sequence of tensors with the same type: <cite>&lt;number&gt; * &lt;type&gt;</cite>, where
<cite>&lt;number&gt;</cite> is the name of an [Attr](#attrs) with type <cite>int</cite>.  The <cite>&lt;type&gt;</cite> can
either be a <cite>tf.DType</cite>,
or the name of an attr with type <cite>type</cite>.  As an example of the first, this
op accepts a list of <cite>int32</cite> tensors:</p>
<p><a href="#id341"><span class="problematic" id="id342">``</span></a><a href="#id343"><span class="problematic" id="id344">`</span></a>c++
REGISTER_OP(«Int32SequenceExample»)</p>
<blockquote>
<div><p>.Attr(«NumTensors: int»)
.Input(«in: NumTensors * int32»)</p>
</div></blockquote>
<p><a href="#id345"><span class="problematic" id="id346">``</span></a><a href="#id347"><span class="problematic" id="id348">`</span></a></p>
<p>Whereas this op accepts a list of tensors of any type, as long as they are all
the same:</p>
<p><a href="#id349"><span class="problematic" id="id350">``</span></a><a href="#id351"><span class="problematic" id="id352">`</span></a>c++
REGISTER_OP(«SameTypeSequenceExample»)</p>
<blockquote>
<div><p>.Attr(«NumTensors: int»)
.Attr(«T: type»)
.Input(«in: NumTensors * T»)</p>
</div></blockquote>
<p><a href="#id353"><span class="problematic" id="id354">``</span></a><a href="#id355"><span class="problematic" id="id356">`</span></a></p>
</li>
<li><p>For a reference to a tensor: <cite>Ref(&lt;type&gt;)</cite>, where <cite>&lt;type&gt;</cite> is one of the
previous types.</p></li>
</ul>
<p>Any attr used in the type of an input will be inferred. By convention those
inferred attrs use capital names (like <cite>T</cite> or <cite>N</cite>). Otherwise inputs, outputs,
and attrs have names like function parameters (e.g. <cite>num_outputs</cite>). For more
details, see the [earlier section on naming](#naming).</p>
<p>For more details, see
[<cite>tensorflow/core/framework/op_def_builder.h</cite>][op_def_builder].</p>
<p>#### Backwards compatibility</p>
<p>Let’s assume you have written a nice, custom op and shared it with others, so
you have happy customers using your operation.  However, you’d like to make
changes to the op in some way.</p>
<p>In general, changes to existing, checked-in specifications must be
backwards-compatible: changing the specification of an op must not break prior
serialized <cite>GraphDef</cite> protocol buffers constructed from older specifications.
The details of <cite>GraphDef</cite> compatibility are
[described here](./versions.md#compatibility_of_graphs_and_checkpoints).</p>
<p>There are several ways to preserve backwards-compatibility.</p>
<ol class="arabic">
<li><p>Any new attrs added to an operation must have default values defined, and
with that default value the op must have the original behavior. To change an
operation from not polymorphic to polymorphic, you <em>must</em> give a default
value to the new type attr to preserve the original signature by default.
For example, if your operation was:</p>
<p><a href="#id357"><span class="problematic" id="id358">``</span></a><a href="#id359"><span class="problematic" id="id360">`</span></a>c++
REGISTER_OP(«MyGeneralUnaryOp»)</p>
<blockquote>
<div><p>.Input(«in: float»)
.Output(«out: float»);</p>
</div></blockquote>
<p><a href="#id361"><span class="problematic" id="id362">``</span></a><a href="#id363"><span class="problematic" id="id364">`</span></a></p>
<p>you can make it polymorphic in a backwards-compatible way using:</p>
<p><a href="#id365"><span class="problematic" id="id366">``</span></a><a href="#id367"><span class="problematic" id="id368">`</span></a>c++
REGISTER_OP(«MyGeneralUnaryOp»)</p>
<blockquote>
<div><p>.Input(«in: T»)
.Output(«out: T»)
.Attr(«T: numerictype = DT_FLOAT»);</p>
</div></blockquote>
<p><a href="#id369"><span class="problematic" id="id370">``</span></a><a href="#id371"><span class="problematic" id="id372">`</span></a></p>
</li>
<li><p>You can safely make a constraint on an attr less restrictive. For example,
you can change from <cite>{int32, int64}</cite> to <cite>{int32, int64, float}</cite> or <cite>type</cite>.
Or you may change from <cite>{«apple», «orange»}</cite> to <cite>{«apple», «banana»,
«orange»}</cite> or <cite>string</cite>.</p></li>
<li><p>You can change single inputs / outputs into list inputs / outputs, as long
as the default for the list type matches the old signature.</p></li>
<li><p>You can add a new list input / output, if it defaults to empty.</p></li>
<li><p>Namespace any new ops you create, by prefixing the op names with something
unique to your project. This avoids having your op colliding with any ops
that might be included in future versions of TensorFlow.</p></li>
<li><p>Plan ahead! Try to anticipate future uses for the op. Some signature changes
can’t be done in a compatible way (for example, making a list of the same
type into a list of varying types).</p></li>
</ol>
<p>The full list of safe and unsafe changes can be found in
[<cite>tensorflow/core/framework/op_compatibility_test.cc</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/op_compatibility_test.cc">https://www.tensorflow.org/code/tensorflow/core/framework/op_compatibility_test.cc</a>).
If you cannot make your change to an operation backwards compatible, then create
a new operation with a new name with the new semantics.</p>
<p>Also note that while these changes can maintain <cite>GraphDef</cite> compatibility, the
generated Python code may change in a way that isn’t compatible with old
callers.  The Python API may be kept compatible by careful changes in a
hand-written Python wrapper, by keeping the old signature except possibly adding
new optional arguments to the end.  Generally incompatible changes may only be
made when TensorFlow changes major versions, and must conform to the
[<cite>GraphDef</cite> version semantics](./versions.md#compatibility_of_graphs_and_checkpoints).</p>
<p>### GPU support</p>
<p>You can implement different OpKernels and register one for CPU and another for
GPU, just like you can [register kernels for different types](#polymorphism).
There are several examples of kernels with GPU support in
[<cite>tensorflow/core/kernels/</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/kernels/">https://www.tensorflow.org/code/tensorflow/core/kernels/</a>).
Notice some kernels have a CPU version in a <cite>.cc</cite> file, a GPU version in a file
ending in <cite>_gpu.cu.cc</cite>, and some code shared in common in a <cite>.h</cite> file.</p>
<p>For example, the <cite>tf.pad</cite> has
everything but the GPU kernel in [<cite>tensorflow/core/kernels/pad_op.cc</cite>][pad_op].
The GPU kernel is in
[<cite>tensorflow/core/kernels/pad_op_gpu.cu.cc</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op_gpu.cu.cc">https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op_gpu.cu.cc</a>),
and the shared code is a templated class defined in
[<cite>tensorflow/core/kernels/pad_op.h</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op.h">https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op.h</a>).
We organize the code this way for two reasons: it allows you to share common
code among the CPU and GPU implementations, and it puts the GPU implementation
into a separate file so that it can be compiled only by the GPU compiler.</p>
<p>One thing to note, even when the GPU kernel version of <cite>pad</cite> is used, it still
needs its <cite>«paddings»</cite> input in CPU memory.  To mark that inputs or outputs are
kept on the CPU, add a <cite>HostMemory()</cite> call to the kernel registration, e.g.:</p>
<p><a href="#id373"><span class="problematic" id="id374">``</span></a><a href="#id375"><span class="problematic" id="id376">`</span></a>c++
#define REGISTER_GPU_KERNEL(T)                         </p>
<blockquote>
<div><dl>
<dt>REGISTER_KERNEL_BUILDER(Name(«Pad»)                  </dt><dd><blockquote>
<div><p>.Device(DEVICE_GPU)      .TypeConstraint&lt;T&gt;(«T»)  .HostMemory(«paddings»), </p>
</div></blockquote>
<p>PadOp&lt;GPUDevice, T&gt;)</p>
</dd>
</dl>
</div></blockquote>
<p><a href="#id377"><span class="problematic" id="id378">``</span></a><a href="#id379"><span class="problematic" id="id380">`</span></a></p>
<p>#### Compiling the kernel for the GPU device</p>
<p>Look at
[cuda_op_kernel.cu.cc](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cu.cc">https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cu.cc</a>)
for an example that uses a CUDA kernel to implement an op. The
<cite>tf_custom_op_library</cite> accepts a <cite>gpu_srcs</cite> argument in which the list of source
files containing the CUDA kernels (<cite>*.cu.cc</cite> files) can be specified. For use
with a binary installation of TensorFlow, the CUDA kernels have to be compiled
with NVIDIA’s <cite>nvcc</cite> compiler. Here is the sequence of commands you can use to
compile the
[cuda_op_kernel.cu.cc](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cu.cc">https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cu.cc</a>)
and
[cuda_op_kernel.cc](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cc">https://www.tensorflow.org/code/tensorflow/examples/adding_an_op/cuda_op_kernel.cc</a>)
into a single dynamically loadable library:</p>
<p><a href="#id381"><span class="problematic" id="id382">``</span></a><a href="#id383"><span class="problematic" id="id384">`</span></a>bash
nvcc -std=c++11 -c -o cuda_op_kernel.cu.o cuda_op_kernel.cu.cc </p>
<blockquote>
<div><p>${TF_CFLAGS[&#64;]} -D GOOGLE_CUDA=1 -x cu -Xcompiler -fPIC</p>
</div></blockquote>
<dl class="simple">
<dt>g++ -std=c++11 -shared -o cuda_op_kernel.so cuda_op_kernel.cc </dt><dd><p>cuda_op_kernel.cu.o ${TF_CFLAGS[&#64;]} -fPIC -lcudart ${TF_LFLAGS[&#64;]}</p>
</dd>
</dl>
<p><a href="#id385"><span class="problematic" id="id386">``</span></a><a href="#id387"><span class="problematic" id="id388">`</span></a></p>
<p><cite>cuda_op_kernel.so</cite> produced above can be loaded as usual in Python, using the
<cite>tf.load_op_library</cite> function.</p>
<p>Note that if your CUDA libraries are not installed in <cite>/usr/local/lib64</cite>,
you’ll need to specify the path explicitly in the second (g++) command above.
For example, add <cite>-L /usr/local/cuda-8.0/lib64/</cite> if your CUDA is installed in
<cite>/usr/local/cuda-8.0</cite>.</p>
<p>Note: In some Linux settings, additional options to <cite>nvcc</cite> compiling step are
needed. Add <cite>-D_MWAITXINTRIN_H_INCLUDED</cite> to the <cite>nvcc</cite> command line to avoid
errors from <cite>mwaitxintrin.h</cite>.</p>
<p>### Implement the gradient in Python</p>
<p>Given a graph of ops, TensorFlow uses automatic differentiation
(backpropagation) to add new ops representing gradients with respect to the
existing ops.
To make automatic differentiation work for new ops, you must register a gradient
function which computes gradients with respect to the ops” inputs given
gradients with respect to the ops” outputs.</p>
<p>Mathematically, if an op computes \(y = f(x)\) the registered gradient op
converts gradients \(partial L/ partial y\) of loss \(L\) with respect to
\(y\) into gradients \(partial L/ partial x\) with respect to \(x\) via
the chain rule:</p>
<dl class="simple">
<dt>$$frac{partial L}{partial x}</dt><dd><p>= frac{partial L}{partial y} frac{partial y}{partial x}
= frac{partial L}{partial y} frac{partial f}{partial x}.$$</p>
</dd>
</dl>
<p>In the case of <cite>ZeroOut</cite>, only one entry in the input affects the output, so the
gradient with respect to the input is a sparse «one hot» tensor.  This is
expressed as follows:</p>
<p><a href="#id389"><span class="problematic" id="id390">``</span></a><a href="#id391"><span class="problematic" id="id392">`</span></a>python
from tensorflow.python.framework import ops
from tensorflow.python.ops import array_ops
from tensorflow.python.ops import sparse_ops</p>
<p>&#64;ops.RegisterGradient(«ZeroOut»)
def _zero_out_grad(op, grad):</p>
<blockquote>
<div><p>«»»The gradients for <cite>zero_out</cite>.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>op: The <cite>zero_out</cite> <cite>Operation</cite> that we are differentiating, which we can use</dt><dd><p>to find the inputs and outputs of the original op.</p>
</dd>
</dl>
<p>grad: Gradient with respect to the output of the <cite>zero_out</cite> op.</p>
</dd>
<dt>Returns:</dt><dd><p>Gradients with respect to the input of <cite>zero_out</cite>.</p>
</dd>
</dl>
<p>«»»
to_zero = op.inputs[0]
shape = array_ops.shape(to_zero)
index = array_ops.zeros_like(shape)
first_grad = array_ops.reshape(grad, [-1])[0]
to_zero_grad = sparse_ops.sparse_to_dense([index], shape, first_grad, 0)
return [to_zero_grad]  # List of one Tensor, since we have one input</p>
</div></blockquote>
<p><a href="#id393"><span class="problematic" id="id394">``</span></a><a href="#id395"><span class="problematic" id="id396">`</span></a></p>
<p>Details about registering gradient functions with
<cite>tf.RegisterGradient</cite>:</p>
<ul class="simple">
<li><p>For an op with one output, the gradient function will take an <cite>tf.Operation</cite>,
<cite>op</cite>, and a <cite>tf.Tensor</cite> <cite>grad</cite> and build new ops out of the tensors
<cite>op.inputs[i]</cite>, <cite>op.outputs[i]</cite>, and <cite>grad</cite>. Information about any attrs can
be found via <cite>tf.Operation.get_attr</cite>.</p></li>
<li><p>If the op has multiple outputs, the gradient function will take <cite>op</cite> and
<cite>grads</cite>, where <cite>grads</cite> is a list of gradients with respect to each output.
The result of the gradient function must be a list of <cite>Tensor</cite> objects
representing the gradients with respect to each input.</p></li>
<li><p>If there is no well-defined gradient for some input, such as for integer
inputs used as indices, the corresponding returned gradient should be
<cite>None</cite>.  For example, for an op taking a floating point tensor <cite>x</cite> and an
integer index <cite>i</cite>, the gradient function would <cite>return [x_grad, None]</cite>.</p></li>
<li><p>If there is no meaningful gradient for the op at all, you often will not have
to register any gradient, and as long as the op’s gradient is never needed,
you will be fine. In some cases, an op has no well-defined gradient but can
be involved in the computation of the gradient. Here you can use
<cite>ops.NotDifferentiable</cite> to automatically propagate zeros backwards.</p></li>
</ul>
<p>Note that at the time the gradient function is called, only the data flow graph
of ops is available, not the tensor data itself.  Thus, all computation must be
performed using other tensorflow ops, to be run at graph execution time.</p>
<p>### Shape functions in C++</p>
<p>The TensorFlow API has a feature called «shape inference» that provides
information about the shapes of tensors without having to execute the
graph. Shape inference is supported by «shape functions» that are registered for
each op type in the C++ <cite>REGISTER_OP</cite> declaration, and perform two roles:
asserting that the shapes of the inputs are compatible during graph
construction, and specifying the shapes for the outputs.</p>
<p>Shape functions are defined as operations on the
<cite>shape_inference::InferenceContext</cite> class. For example, in the shape function
for ZeroOut:</p>
<dl>
<dt><a href="#id397"><span class="problematic" id="id398">``</span></a><a href="#id399"><span class="problematic" id="id400">`</span></a>c++</dt><dd><dl class="simple">
<dt>.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</dt><dd><p>c-&gt;set_output(0, c-&gt;input(0));
return Status::OK();</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p><a href="#id401"><span class="problematic" id="id402">``</span></a><a href="#id403"><span class="problematic" id="id404">`</span></a></p>
<p><cite>c-&gt;set_output(0, c-&gt;input(0));</cite> declares that the first output’s shape should
be set to the first input’s shape. If the output is selected by its index as in the above example, the second parameter of <cite>set_output</cite> should be a <cite>ShapeHandle</cite> object. You can create an empty <cite>ShapeHandle</cite> object by its default constructor. The <cite>ShapeHandle</cite> object for an input with index <cite>idx</cite> can be obtained by <cite>c-&gt;input(idx)</cite>.</p>
<p>There are a number of common shape functions
that apply to many ops, such as <cite>shape_inference::UnchangedShape</cite> which can be
found in [common_shape_fns.h](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/common_shape_fns.h">https://www.tensorflow.org/code/tensorflow/core/framework/common_shape_fns.h</a>) and used as follows:</p>
<p><a href="#id405"><span class="problematic" id="id406">``</span></a><a href="#id407"><span class="problematic" id="id408">`</span></a>c++
REGISTER_OP(«ZeroOut»)</p>
<blockquote>
<div><p>.Input(«to_zero: int32»)
.Output(«zeroed: int32»)
.SetShapeFn(::tensorflow::shape_inference::UnchangedShape);</p>
</div></blockquote>
<p><a href="#id409"><span class="problematic" id="id410">``</span></a><a href="#id411"><span class="problematic" id="id412">`</span></a></p>
<p>A shape function can also constrain the shape of an input. For the version of
[<cite>ZeroOut</cite> with a vector shape constraint](#conditional-checks-and-validation), the shape function
would be as follows:</p>
<dl>
<dt><a href="#id413"><span class="problematic" id="id414">``</span></a><a href="#id415"><span class="problematic" id="id416">`</span></a>c++</dt><dd><dl class="simple">
<dt>.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</dt><dd><p>::tensorflow::shape_inference::ShapeHandle input;
TF_RETURN_IF_ERROR(c-&gt;WithRank(c-&gt;input(0), 1, &amp;input));
c-&gt;set_output(0, input);
return Status::OK();</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p><a href="#id417"><span class="problematic" id="id418">``</span></a><a href="#id419"><span class="problematic" id="id420">`</span></a></p>
<p>The <cite>WithRank</cite> call validates that the input shape <cite>c-&gt;input(0)</cite> has
a shape with exactly one dimension (or if the input shape is unknown,
the output shape will be a vector with one unknown dimension).</p>
<p>If your op is [polymorphic with multiple inputs](#polymorphism), you can use
members of <cite>InferenceContext</cite> to determine the number of shapes to check, and
<cite>Merge</cite> to validate that the shapes are all compatible (alternatively, access
attributes that indicate the lengths, with <cite>InferenceContext::GetAttr</cite>, which
provides access to the attributes of the op).</p>
<dl>
<dt><a href="#id421"><span class="problematic" id="id422">``</span></a><a href="#id423"><span class="problematic" id="id424">`</span></a>c++</dt><dd><dl>
<dt>.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</dt><dd><p>::tensorflow::shape_inference::ShapeHandle input;
::tensorflow::shape_inference::ShapeHandle output;
for (size_t i = 0; i &lt; c-&gt;num_inputs(); ++i) {</p>
<blockquote>
<div><p>TF_RETURN_IF_ERROR(c-&gt;WithRank(c-&gt;input(i), 2, &amp;input));
TF_RETURN_IF_ERROR(c-&gt;Merge(output, input, &amp;output));</p>
</div></blockquote>
<p>}
c-&gt;set_output(0, output);
return Status::OK();</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p><a href="#id425"><span class="problematic" id="id426">``</span></a><a href="#id427"><span class="problematic" id="id428">`</span></a></p>
<p>Since shape inference is an optional feature, and the shapes of tensors may vary
dynamically, shape functions must be robust to incomplete shape information for
any of the inputs. The <cite>Merge</cite> method in [<cite>InferenceContext</cite>](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/shape_inference.h">https://www.tensorflow.org/code/tensorflow/core/framework/shape_inference.h</a>)
allows the caller to assert that two shapes are the same, even if either
or both of them do not have complete information. Shape functions are defined
for all of the core TensorFlow ops and provide many different usage examples.</p>
<p>The <cite>InferenceContext</cite> class has a number of functions that can be used to
define shape function manipulations.  For example, you can validate that a
particular dimension has a very specific value using <cite>InferenceContext::Dim</cite> and
<cite>InferenceContext::WithValue</cite>; you can specify that an output dimension is the
sum / product of two input dimensions using <cite>InferenceContext::Add</cite> and
<cite>InferenceContext::Multiply</cite>. See the <cite>InferenceContext</cite> class for
all of the various shape manipulations you can specify. The following example sets
shape of the first output to (n, 3), where first input has shape (n, …)</p>
<p><a href="#id429"><span class="problematic" id="id430">``</span></a><a href="#id431"><span class="problematic" id="id432">`</span></a>c++
.SetShapeFn([](::tensorflow::shape_inference::InferenceContext* c) {</p>
<blockquote>
<div><p>c-&gt;set_output(0, c-&gt;Matrix(c-&gt;Dim(c-&gt;input(0), 0), 3));
return Status::OK();</p>
</div></blockquote>
</div>
<div class="section" id="id433">
<h1>});<a class="headerlink" href="#id433" title="Enlazar permanentemente con este título">¶</a></h1>
<p>If you have a complicated shape function, you should consider adding a test for
validating that various input shape combinations produce the expected output
shape combinations.  You can see examples of how to write these tests in some
our
[core ops tests](<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/ops/array_ops_test.cc">https://www.tensorflow.org/code/tensorflow/core/ops/array_ops_test.cc</a>).
(The syntax of <cite>INFER_OK</cite> and <cite>INFER_ERROR</cite> are a little cryptic, but try to be
compact in representing input and output shape specifications in tests.  For
now, see the surrounding comments in those tests to get a sense of the shape
string specification).</p>
<p>## Build a pip package for your custom op</p>
<p>To build a <cite>pip</cite> package for your op, see the
[tensorflow/custom-op](<a class="reference external" href="https://github.com/tensorflow/custom-op">https://github.com/tensorflow/custom-op</a>) example. This
guide shows how to build custom ops from the TensorFlow pip package instead
of building TensorFlow from source.</p>
<p>[core-array_ops]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/ops/array_ops.cc">https://www.tensorflow.org/code/tensorflow/core/ops/array_ops.cc</a>
[python-user_ops]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/python/user_ops/user_ops.py">https://www.tensorflow.org/code/tensorflow/python/user_ops/user_ops.py</a>
[tf-kernels]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/kernels/">https://www.tensorflow.org/code/tensorflow/core/kernels/</a>
[user_ops]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/user_ops/">https://www.tensorflow.org/code/tensorflow/core/user_ops/</a>
[pad_op]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op.cc">https://www.tensorflow.org/code/tensorflow/core/kernels/pad_op.cc</a>
[standard_ops-py]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/python/ops/standard_ops.py">https://www.tensorflow.org/code/tensorflow/python/ops/standard_ops.py</a>
[standard_ops-cc]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/cc/ops/standard_ops.h">https://www.tensorflow.org/code/tensorflow/cc/ops/standard_ops.h</a>
[python-BUILD]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/python/BUILD">https://www.tensorflow.org/code/tensorflow/python/BUILD</a>
[validation-macros]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/lib/core/errors.h">https://www.tensorflow.org/code/tensorflow/core/lib/core/errors.h</a>
[op_def_builder]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/op_def_builder.h">https://www.tensorflow.org/code/tensorflow/core/framework/op_def_builder.h</a>
[register_types]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/register_types.h">https://www.tensorflow.org/code/tensorflow/core/framework/register_types.h</a>
[FinalizeAttr]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/op_def_builder.cc">https://www.tensorflow.org/code/tensorflow/core/framework/op_def_builder.cc</a>
[DataTypeString]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/types.cc">https://www.tensorflow.org/code/tensorflow/core/framework/types.cc</a>
[python-BUILD]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/python/BUILD">https://www.tensorflow.org/code/tensorflow/python/BUILD</a>
[types-proto]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/types.proto">https://www.tensorflow.org/code/tensorflow/core/framework/types.proto</a>
[TensorShapeProto]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/tensor_shape.proto">https://www.tensorflow.org/code/tensorflow/core/framework/tensor_shape.proto</a>
[TensorProto]:<a class="reference external" href="https://www.tensorflow.org/code/tensorflow/core/framework/tensor.proto">https://www.tensorflow.org/code/tensorflow/core/framework/tensor.proto</a></p>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Derechos de autor 2019, Juan D. Velasquez.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>